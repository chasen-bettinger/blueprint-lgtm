// Generated by CoffeeScript 1.4.0
var Auth, E, ITERATIONS, KEY_LENGTH, Q, SALT_SIZE, crypto, sdb,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Q = require('q');

E = require('../lib/error');

crypto = require('crypto');

ITERATIONS = 150000;

SALT_SIZE = 16;

KEY_LENGTH = 32;

sdb = false;

Auth = (function() {

  function Auth(kit) {
    this.server_use = __bind(this.server_use, this);
    sdb = kit.services.db.mysql;
    this.log = kit.services.logger;
    this.config = kit.services.config.auth;
    this.tokenMgr = kit.services.tokenMgr;
    this.pwd_col = sdb.auth.pwd_col;
  }

  Auth.prototype._pbkdf2 = function(p, buf, IT, KL) {
    return Q.ninvoke(crypto, 'pbkdf2', p, buf, IT, KL);
  };

  Auth.prototype.server_use = function(req, res, next) {
    var authHeader, h, p, result, token;
    p = req.params;
    h = req.headers;
    authHeader = false;
    token = false;
    result = false;
    if (h.authorization) {
      authHeader = h.authorization.split(' ', 2);
    }
    token = (authHeader != null ? authHeader.length : void 0) === 2 && authHeader[0].toLowerCase() === 'bearer' ? authHeader[1] : p.auth_token;
    result = token ? this.tokenMgr.decodeAndValidate(token, this.config.key) : {
      err: 'Missing or invalid authorization header'
    };
    req.auth = {
      message: result.err,
      token: result.token,
      authId: result.token ? result.token.iid : null,
      authorize: function(skip_response) {
        var error;
        if (!req.auth.authId) {
          if (skip_response) {
            return false;
          }
          error = new E.OAuthError(401, 'invalid_token', req.auth.message);
          res.setHeader('WWW-Authenticate', "Bearer realm=\"" + this.config.auth.bearer + "\"");
          res.send(error);
          return next();
        } else {
          return true;
        }
      }
    };
    return next();
  };

  Auth.prototype.validateCredentials = function(ctx, username, password) {
    var creds, f, _log, _ref,
      _this = this;
    f = 'Auth:_validateCredentials:';
    _log = (_ref = ctx.log) != null ? _ref : this.log;
    creds = false;
    return Q.resolve().then(function() {
      return sdb.auth.get_auth_credentials(ctx, username);
    }).then(function(db_rows) {
      _log.debug('got credentials:', db_rows);
      if (db_rows.length !== 1 || !db_rows[0][_this.pwd_col]) {
        throw new E.OAuthError(401, 'invalid_client');
      }
      creds = db_rows[0];
      return _this.comparePassword(password, creds[_this.pwd_col]);
    }).then(function(a_match) {
      _log.debug('got a match:', a_match);
      if (!a_match) {
        throw new E.OAuthError(401, 'invalid_client');
      }
      return creds.id;
    });
  };

  Auth.prototype.comparePassword = function(password, compareHash) {
    var f, parts,
      _this = this;
    f = 'Auth:_comparePassword:';
    parts = compareHash.split('.', 2);
    if (parts.length !== 2) {
      throw new E.ServerError('auth_error', 'Missing salt on password hash');
    }
    return (this._pbkdf2(password, new Buffer(parts[0], 'base64'), ITERATIONS, KEY_LENGTH)).then(function(key) {
      if ((new Buffer(key).toString('base64')) === parts[1]) {
        return true;
      } else {
        return false;
      }
    });
  };

  Auth.prototype.encryptPassword = function(password) {
    var saltBuf,
      _this = this;
    saltBuf = false;
    return Q.resolve().then(function() {
      return Q.ninvoke(crypto, 'randomBytes', SALT_SIZE);
    }).then(function(buffer) {
      saltBuf = buffer;
      return _this._pbkdf2(password, saltBuf, ITERATIONS, KEY_LENGTH);
    }).then(function(key) {
      return (saltBuf.toString('base64')) + '.' + new Buffer(key).toString('base64');
    });
  };

  return Auth;

})();

exports.Auth = Auth;
