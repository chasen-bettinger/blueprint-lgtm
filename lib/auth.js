// Generated by CoffeeScript 1.4.0
(function() {
  var Auth, E, ITERATIONS, KEY_LENGTH, Q, SALT_SIZE, crypto, sdb,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Q = require('q');

  E = require('../lib/error');

  crypto = require('crypto');

  ITERATIONS = false;

  SALT_SIZE = false;

  KEY_LENGTH = false;

  sdb = false;

  Auth = (function() {

    function Auth(kit) {
      this.server_use = __bind(this.server_use, this);
      sdb = kit.services.db.mysql;
      this.log = kit.services.logger.log;
      this.config = kit.services.config.auth;
      this.tokenMgr = kit.services.tokenMgr;
      this.pwd_col = sdb.auth.pwd_col;
      ITERATIONS = this.config.pbkdf2.iterations;
      SALT_SIZE = this.config.pbkdf2.salt_size;
      KEY_LENGTH = this.config.pbkdf2.key_length;
    }

    Auth.prototype._pbkdf2 = function(p, buf, IT, KL) {
      return Q.ninvoke(crypto, 'pbkdf2', p, buf, IT, KL);
    };

    Auth.prototype.server_use = function(req, res, next) {
      var authHeader, h, p, result, token,
        _this = this;
      p = req.params;
      h = req.headers;
      authHeader = false;
      token = false;
      result = false;
      if (h.authorization) {
        authHeader = h.authorization.split(' ', 2);
      }
      token = (authHeader != null ? authHeader.length : void 0) === 2 && authHeader[0].toLowerCase() === 'bearer' ? authHeader[1] : p.auth_token;
      result = token ? this.tokenMgr.decodeAndValidate(token, this.config.key) : {
        error: 'Missing or invalid authorization header'
      };
      req.auth = {
        message: result.error,
        token: result.token,
        authId: result.token ? result.token.iid : null,
        authorize: function(skip_response) {
          var error;
          if (!req.auth.authId) {
            if (skip_response) {
              return false;
            }
            error = new E.OAuthError(401, 'invalid_token', req.auth.message);
            res.setHeader('WWW-Authenticate', "Bearer realm=\"" + _this.config.bearer + "\"");
            res.send(error);
            return next();
          } else {
            return true;
          }
        }
      };
      return next();
    };

    Auth.prototype.AuthenticateBasicAuthHeader = function(req) {
      var api_keys, auth, f, _ref, _ref1, _ref2;
      f = 'Auth:AuthenticateBasicAuthHeader:';
      auth = req.authorization;
      api_keys = this.config.basic.api_keys;
      if (auth.scheme !== 'Basic') {
        return 'invalid_scheme';
      }
      if (!(((_ref = auth.basic) != null ? _ref.username : void 0) in api_keys)) {
        return 'invalid_api_key';
      }
      if (((_ref1 = auth.basic) != null ? _ref1.password : void 0) !== ((_ref2 = api_keys[auth.basic.username]) != null ? _ref2.password : void 0)) {
        return 'invalid_password';
      }
      return true;
    };

    Auth.prototype.ValidateCredentials = function(ctx, username, password) {
      var creds, f, _log, _ref,
        _this = this;
      f = 'Auth:_ValidateCredentials:';
      _log = (_ref = ctx.log) != null ? _ref : this.log;
      creds = false;
      return Q.resolve().then(function() {
        return sdb.auth.GetAuthCreds(ctx, username);
      }).then(function(db_rows) {
        if (db_rows.length !== 1 || !db_rows[0][_this.pwd_col]) {
          throw new E.OAuthError(401, 'invalid_client');
        }
        creds = db_rows[0];
        return _this.ComparePassword(password, creds[_this.pwd_col]);
      }).then(function(a_match) {
        if (!a_match) {
          throw new E.OAuthError(401, 'invalid_client');
        }
        return creds.id;
      });
    };

    Auth.prototype.ComparePassword = function(password, compareHash) {
      var f, parts,
        _this = this;
      f = 'Auth:ComparePassword:';
      parts = compareHash.split('.', 2);
      if (parts.length !== 2) {
        throw new E.ServerError('auth_error', 'Missing salt on password hash');
      }
      return (this._pbkdf2(password, new Buffer(parts[0], 'base64'), ITERATIONS, KEY_LENGTH)).then(function(key) {
        if ((new Buffer(key).toString('base64')) === parts[1]) {
          return true;
        } else {
          return false;
        }
      });
    };

    Auth.prototype.EncryptPassword = function(password) {
      var saltBuf,
        _this = this;
      saltBuf = false;
      return Q.resolve().then(function() {
        return Q.ninvoke(crypto, 'randomBytes', SALT_SIZE);
      }).then(function(buffer) {
        saltBuf = buffer;
        return _this._pbkdf2(password, saltBuf, ITERATIONS, KEY_LENGTH);
      }).then(function(key) {
        return (saltBuf.toString('base64')) + '.' + new Buffer(key).toString('base64');
      });
    };

    return Auth;

  })();

  exports.Auth = Auth;

}).call(this);
