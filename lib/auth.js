// Generated by CoffeeScript 1.9.2
(function() {
  var Auth, E, ITERATIONS, KEY_LENGTH, Q, SALT_SIZE, crypto, sdb,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Q = require('q');

  E = require('../lib/error');

  crypto = require('crypto');

  ITERATIONS = false;

  SALT_SIZE = false;

  KEY_LENGTH = false;

  sdb = false;

  Auth = (function() {
    function Auth(kit) {
      this.server_use = bind(this.server_use, this);
      sdb = kit.services.db.mysql;
      this.log = kit.services.logger.log;
      this.config = kit.services.config.auth;
      this.tokenMgr = kit.services.tokenMgr;
      this.pwd_col = sdb.auth.pwd_col;
      ITERATIONS = this.config.pbkdf2.iterations;
      SALT_SIZE = this.config.pbkdf2.salt_size;
      KEY_LENGTH = this.config.pbkdf2.key_length;
    }

    Auth.prototype._pbkdf2 = function(p, buf, IT, KL) {
      return Q.ninvoke(crypto, 'pbkdf2', p, buf, IT, KL);
    };

    Auth.prototype.server_use = function(req, res, next) {
      var authHeader, h, p, result, token;
      p = req.params;
      h = req.headers;
      authHeader = false;
      token = false;
      result = false;
      if (h.authorization) {
        authHeader = h.authorization.split(' ', 2);
      }
      token = (authHeader != null ? authHeader.length : void 0) === 2 && authHeader[0].toLowerCase() === 'bearer' ? authHeader[1] : p.auth_token;
      result = token ? this.tokenMgr.decodeAndValidate(token, this.config.key) : {
        error: 'Missing or invalid authorization header'
      };
      req.auth = {
        message: result.error,
        token: result.token,
        authId: result.token ? result.token.iid : null,
        authorize: (function(_this) {
          return function(skip_response) {
            var error;
            if (!req.auth.authId) {
              if (skip_response) {
                return false;
              }
              error = new E.OAuthError(401, 'invalid_token', req.auth.message);
              res.setHeader('WWW-Authenticate', "Bearer realm=\"" + _this.config.bearer + "\"");
              res.send(error);
              return next();
            } else {
              return true;
            }
          };
        })(this)
      };
      return next();
    };

    Auth.prototype.AuthenticateBasicAuthHeader = function(req) {
      var api_keys, auth, f, ref, ref1, ref2;
      f = 'Auth:AuthenticateBasicAuthHeader:';
      auth = req.authorization;
      api_keys = this.config.basic.api_keys;
      if (auth.scheme !== 'Basic') {
        return 'invalid_scheme';
      }
      if (!(((ref = auth.basic) != null ? ref.username : void 0) in api_keys)) {
        return 'invalid_api_key';
      }
      if (((ref1 = auth.basic) != null ? ref1.password : void 0) !== ((ref2 = api_keys[auth.basic.username]) != null ? ref2.password : void 0)) {
        return 'invalid_password';
      }
      return true;
    };

    Auth.prototype.ValidateCredentials = function(ctx, username, password) {
      var _log, creds, f, ref;
      f = 'Auth:_ValidateCredentials:';
      _log = (ref = ctx.log) != null ? ref : this.log;
      creds = false;
      return Q.resolve().then(function() {
        return sdb.auth.GetAuthCreds(ctx, username);
      }).then((function(_this) {
        return function(db_rows) {
          if (db_rows.length !== 1 || !db_rows[0][_this.pwd_col]) {
            throw new E.OAuthError(401, 'invalid_client');
          }
          creds = db_rows[0];
          return _this.ComparePassword(password, creds[_this.pwd_col]);
        };
      })(this)).then(function(a_match) {
        if (!a_match) {
          throw new E.OAuthError(401, 'invalid_client');
        }
        return creds.id;
      });
    };

    Auth.prototype.ComparePassword = function(password, compareHash) {
      var f, parts;
      f = 'Auth:ComparePassword:';
      parts = compareHash.split('.', 2);
      if (parts.length !== 2) {
        throw new E.ServerError('auth_error', 'Missing salt on password hash');
      }
      return (this._pbkdf2(password, new Buffer(parts[0], 'base64'), ITERATIONS, KEY_LENGTH)).then((function(_this) {
        return function(key) {
          if ((new Buffer(key).toString('base64')) === parts[1]) {
            return true;
          } else {
            return false;
          }
        };
      })(this));
    };

    Auth.prototype.EncryptPassword = function(password) {
      var saltBuf;
      saltBuf = false;
      return Q.resolve().then(function() {
        return Q.ninvoke(crypto, 'randomBytes', SALT_SIZE);
      }).then((function(_this) {
        return function(buffer) {
          saltBuf = buffer;
          return _this._pbkdf2(password, saltBuf, ITERATIONS, KEY_LENGTH);
        };
      })(this)).then(function(key) {
        return (saltBuf.toString('base64')) + '.' + new Buffer(key).toString('base64');
      });
    };

    return Auth;

  })();

  exports.Auth = Auth;

}).call(this);
