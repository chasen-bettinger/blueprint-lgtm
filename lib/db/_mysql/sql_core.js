// Generated by CoffeeScript 1.9.2
(function() {
  var E, Q, SqlCore, _log, _log2, mysql,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Q = require('q');

  E = require('../../error');

  mysql = require('mysql');

  _log = false;

  _log2 = {
    debug: function() {}
  };

  SqlCore = (function() {
    function SqlCore(pool_opts, log) {
      this.method_factory = bind(this.method_factory, this);
      this.StartTransaction = bind(this.StartTransaction, this);
      _log = log;
      if (pool_opts.level2_debug) {
        _log2 = log;
      }
      this.is_db_log_on = pool_opts.level2_debug;
      this.pool = mysql.createPool(pool_opts);
      this.acquire = function(callback) {
        return this.pool.getConnection(callback);
      };
      this.Acquire = Q.nbind(this.acquire, this);
      this.release = function(conn) {
        _log2.debug('DB:SqlCore:release:', 'releasing conn');
        return conn.release();
      };
      this.destroy = function(conn) {
        _log2.debug('DB:SqlCore:destroy:', 'destroying conn');
        return conn.destroy;
      };
      this.sqlQuery = (function(_this) {
        return function(ctx, sql, args) {
          if (_this.is_db_log_on) {
            ctx.log.debug('DB:SqlCore:sqlQuery:', sql);
          }
          if (args && _this.is_db_log_on) {
            ctx.log.debug('DB:SqlCore:args:', args);
          }
          if (ctx.conn === null) {
            throw new E.DbError('DB:SQL:BAD_CONN');
          }
          return (Q.ninvoke(ctx.conn, 'query', sql, args)).then(function(rows_n_cols) {
            if (_this.is_db_log_on) {
              ctx.log.debug('DB:SqlCore:result:', rows_n_cols[0]);
            }
            return rows_n_cols[0];
          });
        };
      })(this);
    }

    SqlCore.prototype.StartTransaction = function(ctx) {
      var f;
      f = 'DB:SqlCore:StartTransaction';
      return Q.resolve().then((function(_this) {
        return function() {
          return _this.sqlQuery(ctx, 'SET TRANSACTION ISOLATION LEVEL SERIALIZABLE');
        };
      })(this)).then((function(_this) {
        return function(db_result) {
          return _this.sqlQuery(ctx, 'START TRANSACTION');
        };
      })(this)).then(function(db_result) {
        return null;
      });
    };

    SqlCore.prototype.method_factory = function(sql_mod, name) {
      var create, delete_by_id, get_collection, ident_tbl, schema, sqlQuery, table, update_by_id;
      if (!sql_mod.table) {
        throw new E.ServerError("DB:CORE:MOD_TABLE", "table undefined for " + name);
      }
      if (!sql_mod.schema) {
        throw new E.ServerError("DB:CORE:MOD_SCHEMA", "schema undefined for " + name);
      }
      table = sql_mod.table;
      ident_tbl = sql_mod.ident_tbl;
      schema = sql_mod.schema;
      sqlQuery = this.sqlQuery;
      if (schema.GetByKey) {
        sql_mod.GetByKey = function(ctx, key, ids, lock) {
          var f;
          f = "DB:" + name + ":GetByKey:";
          if (this.is_db_log_on) {
            ctx.log.debug(f, key);
          }
          return Q.resolve().then((function(_this) {
            return function() {
              var sql;
              if (!schema.GetByKey[key]) {
                throw new E.DbError("DB:CORE:SCHEMA_UNDEFINED:GetByKey_" + key);
              }
              sql = 'SELECT ' + (schema.GetByKey[key].join(',')) + ' FROM ' + table + ' WHERE di= 0 AND ' + key + ' IN (?)';
              if (lock) {
                sql += ' FOR UPDATE';
              }
              return sqlQuery(ctx, sql, [ids]);
            };
          })(this)).then(function(db_rows) {
            return db_rows;
          });
        };
      }
      if (schema.UpdateByKey) {
        sql_mod.UpdateByKey = function(ctx, key, ids, new_values) {
          var f, nm, val;
          f = "DB:" + name + ":UpdateByKey:";
          if (this.is_db_log_on) {
            ctx.log.debug(f, key);
          }
          if (!schema.UpdateByKey[key]) {
            throw new E.DbError("DB:CORE:SCHEMA_UNDEFINED:UpdateByKey_" + key);
          }
          for (nm in new_values) {
            val = new_values[nm];
            if (indexOf.call(schema.UpdateByKey[key], nm) < 0) {
              throw new E.DbError("UPDATE_BY_KEY:COL_NOT_IN_SCHEMA", {
                col: nm,
                value: val
              });
            }
          }
          return Q.resolve().then((function(_this) {
            return function() {
              var arg, cols, sql;
              cols = [];
              arg = [];
              for (nm in new_values) {
                val = new_values[nm];
                cols.push(nm + '= ?');
                arg.push(val);
              }
              arg.push(ids);
              sql = 'UPDATE ' + table + ' SET ' + (cols.join(',')) + ' WHERE ' + key + ' IN (?) AND di= 0';
              return sqlQuery(ctx, sql, arg);
            };
          })(this)).then((function(_this) {
            return function(db_result) {
              return db_result;
            };
          })(this));
        };
      }
      if (schema.DisposeByIds) {
        sql_mod.DisposeByIds = function(ctx, ids) {
          var f;
          f = "DB:" + name + ":DisposeByIds:";
          if (this.is_db_log_on) {
            ctx.log.debug(f, ids);
          }
          return Q.resolve().then((function(_this) {
            return function() {
              var sql;
              sql = 'UPDATE ' + table + ' SET di= 1 WHERE id IN (?)';
              return sqlQuery(ctx, sql, [ids]);
            };
          })(this)).then((function(_this) {
            return function(db_result) {
              return db_result;
            };
          })(this));
        };
      }
      if (schema.get_collection || schema.GetCollection) {
        get_collection = function(ctx) {
          var f, ref, schema_cols;
          f = "DB:" + name + ":get_collection:";
          if (this.is_db_log_on) {
            ctx.log.debug(f);
          }
          schema_cols = (ref = schema.get_collection) != null ? ref : schema.GetCollection;
          return Q.resolve().then((function(_this) {
            return function() {
              var sql;
              sql = 'SELECT ' + (schema_cols.join(',')) + ' FROM ' + table + ' WHERE di= 0';
              return sqlQuery(ctx, sql);
            };
          })(this)).then(function(db_rows) {
            return db_rows;
          });
        };
        sql_mod.get_collection = get_collection;
        sql_mod.GetCollection = get_collection;
      }
      if (schema.get_by_id) {
        sql_mod.get_by_id = function(ctx, id) {
          var f;
          f = "DB:" + name + ":get_by_id:";
          if (this.is_db_log_on) {
            ctx.log.debug(f, id);
          }
          return Q.resolve().then((function(_this) {
            return function() {
              var sql;
              sql = 'SELECT ' + (schema.get_by_id.join(',')) + ' FROM ' + table + ' WHERE id= ? AND di= 0';
              return sqlQuery(ctx, sql, [id]);
            };
          })(this)).then(function(db_rows) {
            return db_rows;
          });
        };
      }
      if (schema.create || schema.Create) {
        create = function(ctx, new_values, re_read) {
          var f, nm, ref, result, schema_cols, val;
          f = "DB:" + name + ":create:";
          if (this.is_db_log_on) {
            ctx.log.debug(f, new_values);
          }
          schema_cols = (ref = schema.create) != null ? ref : schema.Create;
          result = false;
          for (nm in new_values) {
            val = new_values[nm];
            if (indexOf.call(schema_cols, nm) < 0) {
              throw new E.DbError("DB:CORE:BAD_INSERT_COL-" + table + "-" + nm);
            }
          }
          return Q.resolve().then((function(_this) {
            return function() {
              var arg, cols, qs, sql;
              cols = ['cr'];
              qs = ['?'];
              arg = [null];
              for (nm in new_values) {
                val = new_values[nm];
                cols.push(nm);
                qs.push('?');
                arg.push(val);
              }
              sql = 'INSERT INTO ' + table + ' (' + (cols.join(',')) + ') VALUES (' + (qs.join(',')) + ')';
              return sqlQuery(ctx, sql, arg);
            };
          })(this)).then((function(_this) {
            return function(db_result) {
              var sql;
              result = db_result;
              if (db_result.affectedRows !== 1) {
                throw new E.DbError(f + 'NO_INSERT');
              }
              if (re_read !== true) {
                return false;
              }
              if (!schema.reread) {
                throw new E.ServerError(f + 'REREAD_NOT_DEFINED_IN_SCHEMA');
              }
              sql = 'SELECT ' + (schema.reread.join(',')) + ' FROM ' + table + ' WHERE id= ?';
              return sqlQuery(ctx, sql, [db_result.insertId]);
            };
          })(this)).then(function(db_rows) {
            if (db_rows !== false) {
              if (db_rows.length !== 1) {
                throw new E.NotFoundError(f + 'REREAD');
              }
              result = db_rows[0];
            }
            return result;
          });
        };
        sql_mod.create = create;
        sql_mod.Create = create;
      }
      if (schema.update_by_id || schema.UpdateById) {
        update_by_id = function(ctx, id, new_values, re_read) {
          var f, nm, ref, result, schema_cols, val;
          f = "DB:" + name + ":update_by_id:";
          if (this.is_db_log_on) {
            ctx.log.debug(f, {
              id: id,
              new_values: new_values,
              re_read: re_read
            });
          }
          schema_cols = (ref = schema.update_by_id) != null ? ref : schema.UpdateById;
          result = false;
          for (nm in new_values) {
            val = new_values[nm];
            if (indexOf.call(schema_cols, nm) < 0) {
              throw new E.DbError('Invalid ' + table + ' Update Column', {
                col: nm,
                value: val
              });
            }
          }
          return Q.resolve().then((function(_this) {
            return function() {
              var arg, cols, sql;
              cols = [];
              arg = [];
              for (nm in new_values) {
                val = new_values[nm];
                cols.push(nm + '= ?');
                arg.push(val);
              }
              arg.push(id);
              sql = 'UPDATE ' + table + ' SET ' + (cols.join(',')) + ' WHERE id= ? AND di= 0';
              return sqlQuery(ctx, sql, arg);
            };
          })(this)).then((function(_this) {
            return function(db_result) {
              var sql;
              result = db_result;
              if (re_read !== true) {
                return false;
              }
              if (!schema.reread) {
                throw new E.ServerError(f + 'REREAD_NOT_DEFINED_IN_SCHEMA');
              }
              sql = 'SELECT ' + (schema.reread.join(',')) + ' FROM ' + table + ' WHERE id= ?';
              return sqlQuery(ctx, sql, [id]);
            };
          })(this)).then(function(db_rows) {
            if (db_rows !== false) {
              if (db_rows.length !== 1) {
                throw new E.NotFoundError(f + 'REREAD');
              }
              result = db_rows[0];
            }
            return result;
          });
        };
        sql_mod.update_by_id = update_by_id;
        sql_mod.UpdateById = update_by_id;
      }
      if (schema.delete_by_id || schema.DeleteById) {
        delete_by_id = function(ctx, id) {
          var sql;
          sql = 'DELETE FROM ' + table + ' WHERE id= ?';
          return (sqlQuery(ctx, sql, [id])).then((function(_this) {
            return function(db_result) {
              return db_result;
            };
          })(this));
        };
        sql_mod.delete_by_id = delete_by_id;
        return sql_mod.DeleteById = delete_by_id;
      }
    };

    return SqlCore;

  })();

  exports.SqlCore = SqlCore;

}).call(this);
