// Generated by CoffeeScript 1.6.3
(function() {
  var E, Pool, Q, SqlCore, mysql, _log,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  mysql = require('mysql');

  Pool = require('generic-pool').Pool;

  Q = require('q');

  E = require('../../error');

  _log = false;

  SqlCore = (function() {
    function SqlCore(config, log) {
      this.method_factory = __bind(this.method_factory, this);
      this.StartTransaction = __bind(this.StartTransaction, this);
      _log = log;
      this.pool = Pool({
        name: 'mysql - Blueprint',
        create: function(cb) {
          var conn;
          conn = mysql.createConnection(config);
          return cb(null, conn);
        },
        destroy: function(conn) {
          return conn.end();
        },
        max: config.maxConnections,
        min: config.minConnections,
        idleTimeoutMillis: config.idleTimeoutMillis,
        log: false
      });
      this.acquire = function(callback) {
        return this.pool.acquire(callback);
      };
      this.Acquire = Q.nbind(this.acquire, this);
      this.release = function(conn) {
        _log.debug('DB:SqlCore:release:', 'releasing conn');
        return this.pool.release(conn);
      };
      this.destroy = function(conn) {
        return this.pool.destroy(conn);
      };
      this.sqlQuery = function(ctx, sql, args) {
        _log.debug('DB:SqlCore:sqlQuery:', sql);
        if (args) {
          _log.debug('DB:SqlCore:args:', args);
        }
        if (ctx.conn === null) {
          throw new E.DbError('DB:SQL:BAD_CONN');
        }
        return (Q.ninvoke(ctx.conn, 'query', sql, args)).then(function(rows_n_cols) {
          return rows_n_cols[0];
        });
      };
    }

    SqlCore.prototype.StartTransaction = function(ctx) {
      var f,
        _this = this;
      f = 'DB:SqlCore:StartTransaction';
      return Q.resolve().then(function() {
        return _this.sqlQuery(ctx, 'SET TRANSACTION ISOLATION LEVEL SERIALIZABLE');
      }).then(function(db_result) {
        return _this.sqlQuery(ctx, 'START TRANSACTION');
      }).then(function(db_result) {
        return null;
      });
    };

    SqlCore.prototype.method_factory = function(sql_mod, name) {
      var ident_tbl, schema, sqlQuery, table;
      table = sql_mod.table;
      ident_tbl = sql_mod.ident_tbl;
      schema = sql_mod.schema;
      sqlQuery = this.sqlQuery;
      if (schema.get_collection) {
        sql_mod.get_collection = function(ctx) {
          var f,
            _this = this;
          f = "DB:" + name + ":get_collection:";
          return Q.resolve().then(function() {
            var sql;
            sql = 'SELECT * FROM ' + table;
            return sqlQuery(ctx, sql);
          }).then(function(db_rows) {
            return db_rows;
          });
        };
      }
      if (schema.get_by_id) {
        sql_mod.get_by_id = function(ctx, id) {
          var f,
            _this = this;
          f = "DB:" + name + ":get_by_id:";
          return Q.resolve().then(function() {
            var sql;
            sql = 'SELECT ' + (schema.get_by_id.join(',')) + ' FROM ' + table + ' WHERE id= ? AND di= 0';
            return sqlQuery(ctx, sql, [id]);
          }).then(function(db_rows) {
            return db_rows;
          });
        };
      }
      if (schema.create) {
        sql_mod.create = function(ctx, new_values) {
          var f, nm, val,
            _this = this;
          f = "DB:" + name + ":create:";
          _log.debug(f, new_values);
          for (nm in new_values) {
            val = new_values[nm];
            if (__indexOf.call(schema.create, nm) < 0) {
              throw new E.ServerError('Invalid ' + table + ' Insert Column', {
                col: nm,
                value: val
              });
            }
          }
          return Q.resolve().then(function() {
            var arg, cols, qs, sql;
            cols = ['cr'];
            qs = ['?'];
            arg = [null];
            for (nm in new_values) {
              val = new_values[nm];
              cols.push(nm);
              qs.push('?');
              arg.push(val);
            }
            sql = 'INSERT INTO ' + table + ' (' + (cols.join(',')) + ') VALUES (' + (qs.join(',')) + ')';
            return sqlQuery(ctx, sql, arg);
          }).then(function(db_result) {
            return db_result;
          });
        };
      }
      if (schema.update_by_ident_id) {
        sql_mod.update_by_ident_id = function(ctx, ident_id, new_values) {
          var f, nm, val,
            _this = this;
          f = "DB:" + name + ":update_by_ident_id:";
          _log.debug(f, ident_id, new_values);
          for (nm in new_values) {
            val = new_values[nm];
            if (__indexOf.call(schema.update_by_ident_id, nm) < 0) {
              throw new E.DbError('Invalid ' + table + ' Update Column', {
                col: nm,
                value: val
              });
            }
          }
          return Q.resolve().then(function() {
            var arg, cols, sql;
            cols = [];
            arg = [];
            for (nm in new_values) {
              val = new_values[nm];
              cols.push(nm + '= ?');
              arg.push(val);
            }
            arg.push(ident_id);
            sql = 'UPDATE ' + table + ' SET ' + (cols.join(',')) + ' WHERE ident_id= ? AND di= 0';
            return sqlQuery(ctx, sql, arg);
          }).then(function(db_result) {
            return db_result;
          });
        };
      }
      if (schema.update_by_id) {
        sql_mod.update_by_id = function(ctx, id, new_values) {
          var f, nm, val,
            _this = this;
          f = "DB:" + name + ":update_by_id:";
          _log.debug(f, id, new_values);
          for (nm in new_values) {
            val = new_values[nm];
            if (__indexOf.call(schema.update_by_id, nm) < 0) {
              throw new E.DbError('Invalid ' + table + ' Update Column', {
                col: nm,
                value: val
              });
            }
          }
          return Q.resolve().then(function() {
            var arg, cols, sql;
            cols = [];
            arg = [];
            for (nm in new_values) {
              val = new_values[nm];
              cols.push(nm + '= ?');
              arg.push(val);
            }
            arg.push(id);
            sql = 'UPDATE ' + table + ' SET ' + (cols.join(',')) + ' WHERE id= ? AND di= 0';
            return sqlQuery(ctx, sql, arg);
          }).then(function(db_result) {
            return db_result;
          });
        };
      }
      if (schema.get_by_ident_id) {
        return sql_mod.get_by_ident_id = function(ctx, ident_id) {
          var f,
            _this = this;
          f = "DB:" + name + ":get_by_ident_id:";
          _log.debug(f, ident_id);
          return Q.resolve().then(function() {
            var sql;
            sql = 'SELECT ' + (schema.get_by_ident_id.join(',')) + ' FROM ' + ident_tbl + ' i LEFT OUTER JOIN ' + table + ' e' + ' ON i.id= e.ident_id WHERE i.id= ? AND i.di= 0 AND (e.di= 0 OR e.id IS NULL)';
            return sqlQuery(ctx, sql, [ident_id]);
          }).then(function(db_rows) {
            return db_rows;
          });
        };
      }
    };

    return SqlCore;

  })();

  exports.SqlCore = SqlCore;

}).call(this);
