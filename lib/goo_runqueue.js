// Generated by CoffeeScript 1.9.2
(function() {
  var Promise, RunQueueMongoDbPersistence, RunQueueMongoDbSchema, _, mongoose, showme;

  _ = require('lodash');

  Promise = require('bluebird');

  mongoose = require('mongoose');

  mongoose.Promise = Promise;

  RunQueueMongoDbSchema = require('./goo_schema_runqueue');

  showme = function(f, obj) {
    var nm, ref, ref1, val;
    return console.log("SHOWME: " + f + " " + (typeof obj) + " " + ((ref = obj != null ? (ref1 = obj.constructor) != null ? ref1.name : void 0 : void 0) != null ? ref : 'no-name'), (obj != null) && typeof obj === 'object' ? {
      keys: Object.keys(obj),
      funcs: ((function() {
        var results1;
        results1 = [];
        for (nm in obj) {
          val = obj[nm];
          if (typeof val === 'function') {
            results1.push(nm);
          }
        }
        return results1;
      })()).join(),
      mongo_stuff: _.pick(obj, 'lastErrorObject', 'value', 'ok'),
      mongoose_stuff: _.pick(obj, 'isNew', 'errors', '_doc')
    } : {});
  };

  RunQueueMongoDbPersistence = (function() {
    RunQueueMongoDbPersistence.deps = {};

    function RunQueueMongoDbPersistence() {
      this._schema = new RunQueueMongoDbSchema();
    }

    RunQueueMongoDbPersistence.prototype.open = function(uri) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return mongoose.connect(uri, function(err) {
            if (err) {
              reject(err);
            }
            _this._connection = mongoose.connection;
            _this._model = mongoose.model('RunQueue', _this._schema);
            return resolve();
          });
        };
      })(this));
    };

    RunQueueMongoDbPersistence.prototype.close = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this._model === null) {
            return resolve();
          }
          return mongoose.disconnect(function(err) {
            _this._model = null;
            if (err) {
              return reject(err);
            } else {
              return resolve();
            }
          });
        };
      })(this));
    };

    RunQueueMongoDbPersistence.prototype.clear = function() {
      return this._model.remove({});
    };

    RunQueueMongoDbPersistence.prototype.GetJobById = function(ctx, id) {
      return this._model.findById(id);
    };

    RunQueueMongoDbPersistence.prototype.GetPendingCnts = function(ctx) {
      var pipeline;
      pipeline = [
        {
          $match: {
            in_process: 1,
            di: 0
          }
        }, {
          $group: {
            _id: '$group_ref',
            count: {
              $sum: 1
            }
          }
        }
      ];
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this._model.aggregate(pipeline, function(err, results) {
            if (err) {
              return reject(err);
            } else if (results == null) {
              return resolve([]);
            }
            return resolve(_.map(results, function(r) {
              return {
                group_ref: r._id,
                active_cnt: r.count
              };
            }));
          });
        };
      })(this));
    };

    RunQueueMongoDbPersistence.prototype.GetNextJobs = function(ctx, maxRows, maxRetries) {
      var conditions;
      if (maxRetries == null) {
        maxRetries = 8;
      }
      conditions = {
        in_process: 0,
        run_at: {
          $lte: new Date()
        },
        retries: {
          $lte: maxRetries
        },
        di: 0
      };
      return this._model.find(conditions).sort({
        priority: 1,
        run_at: 1
      }).limit(maxRows).then(function(model_result) {
        var i, len, results1, row;
        console.log(model_result);
        results1 = [];
        for (i = 0, len = model_result.length; i < len; i++) {
          row = model_result[i];
          results1.push(row._doc);
        }
        return results1;
      });
    };

    RunQueueMongoDbPersistence.prototype.AddJob = function(ctx, newValues, reread) {
      var f, options;
      if (reread == null) {
        reread = false;
      }
      f = 'RunQueueMongoDbPersistence::AddJob:';
      newValues = _.pick(newValues, 'unique_key', 'topic', 'group_ref', 'priority', 'run_at', 'json');
      _.merge(newValues, {
        mo: new Date(),
        in_process: 0,
        retries: 0
      });
      newValues.in_process = 5;
      options = {};
      console.log(f + 'SAVE', {
        newValues: newValues,
        options: options
      });
      return new this._model(newValues).save(options).then(function(model_result) {
        showme(f, model_result);
        if (reread) {
          [model_result.toJSON()];
        } else {
          ({
            affectedRows: 1,
            insertId: model_result.toJSON().id
          });
        }
        return [model_result.toJSON()];
      });
    };

    RunQueueMongoDbPersistence.prototype.ReplaceJob = function(ctx, id, newValues, reread) {
      var defaults, doc, i, len, nm, options, ref, unset;
      if (reread == null) {
        reread = false;
      }
      newValues = _.pick(newValues, 'unique_key', 'priority', 'run_at', 'json');
      defaults = {
        in_process: 0,
        retries: 0
      };
      newValues = _.merge({}, defaults, newValues);
      newValues.mo = new Date();
      unset = {};
      ref = ['fail_at', 'last_reason', 'unique_key', 'json'];
      for (i = 0, len = ref.length; i < len; i++) {
        nm = ref[i];
        if (!(nm in newValues)) {
          unset[nm] = '';
        }
      }
      doc = {
        $set: newValues,
        $unset: unset
      };
      options = {
        "new": true
      };
      return this._model.findByIdAndUpdate(id, doc, options).then(function(model_result) {
        if (reread) {
          return [model_result._doc];
        } else {
          return model_result.result;
        }
      });
    };

    RunQueueMongoDbPersistence.prototype.MarkJobPending = function(ctx, id, otherValues, reread) {
      var conditions, doc, f, newValues, options;
      if (reread == null) {
        reread = false;
      }
      f = 'RunQueueMongoDbPersistence::MarkJobPending:';
      newValues = otherValues != null ? otherValues : {};
      newValues = _.pick(newValues, 'unique_key', 'priority', 'run_at', 'json', 'fail_at');
      newValues.mo = new Date();
      newValues.in_process = 1;
      conditions = {
        _id: id,
        in_process: 0
      };
      doc = {
        $set: newValues
      };
      options = {
        "new": true,
        rawResult: true
      };
      console.log('##### QUERY >>>', {
        conditions: conditions,
        doc: doc,
        options: options
      });
      return this._model.findOneAndUpdate(conditions, doc, options).then(function(mongo_result) {
        var ref;
        showme(f, mongo_result);
        if (mongo_result && ((ref = mongo_result.lastErrorObject) != null ? ref.n : void 0) === 1) {
          if (reread) {
            return [mongo_result.value._doc];
          } else {
            return {
              affectedRows: 1
            };
          }
        } else {
          if (reread) {
            return [];
          } else {
            return {
              affectedRows: 0
            };
          }
        }
      });
    };

    RunQueueMongoDbPersistence.prototype.Fail = function(ctx, id, newValues, reread) {
      var doc, options;
      if (reread == null) {
        reread = false;
      }
      newValues = _.pick(newValues, 'last_reason', 'run_at');
      newValues.mo = new Date();
      newValues.in_process = 0;
      doc = {
        $set: newValues,
        $inc: {
          retries: 1
        },
        $unset: {
          fail_at: ''
        }
      };
      options = {
        "new": true
      };
      return this._model.findByIdAndUpdate(id, doc, options).then(function(model_result) {
        if (reread) {
          return [model_result._doc];
        } else {
          return model_result.result;
        }
      });
    };

    RunQueueMongoDbPersistence.prototype.RemoveByIds = function(ctx, ids) {
      var conditions, doc;
      if (!_.isArray(ids)) {
        ids = [ids];
      }
      conditions = {
        _id: {
          $in: ids
        }
      };
      doc = {
        $set: {
          mo: new Date(),
          di: 1
        }
      };
      return this._model.updateMany(conditions, doc);
    };

    RunQueueMongoDbPersistence.prototype.RemoveByUniqueKeys = function(ctx, uniqueKeys) {
      var conditions, doc;
      if (!_.isArray(uniqueKeys)) {
        uniqueKeys = [uniqueKeys];
      }
      conditions = {
        unique_key: {
          $in: uniqueKeys
        }
      };
      doc = {
        $set: {
          mo: new Date(),
          di: 1
        }
      };
      return this._model.updateMany(conditions, doc);
    };

    RunQueueMongoDbPersistence.prototype.GetDelayedByTopic = function(ctx) {
      var pipeline;
      pipeline = [
        {
          $match: {
            di: 0,
            in_process: 0,
            run_at: {
              $lte: new Date()
            }
          }
        }, {
          $group: {
            _id: "$topic",
            run_at: {
              $min: '$run_at'
            }
          }
        }, {
          $addFields: {
            delay: {
              $subtract: [new Date(), "$run_at"]
            }
          }
        }
      ];
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this._model.aggregate(pipeline, function(err, results) {
            if (err) {
              return reject(err);
            } else if (results == null) {
              return resolve([]);
            }
            return resolve(_.map(results, function(r) {
              return {
                topic: r._id,
                delay: Math.floor(r.delay / 1000)
              };
            }));
          });
        };
      })(this));
    };

    RunQueueMongoDbPersistence.prototype.GetRetriesByTopic = function(ctx) {
      var pipeline;
      pipeline = [
        {
          $match: {
            di: 0,
            retries: {
              $gt: 0
            }
          }
        }, {
          $group: {
            _id: "$topic",
            max_retries: {
              $max: '$retries'
            }
          }
        }
      ];
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this._model.aggregate(pipeline, function(err, results) {
            if (err) {
              return reject(err);
            } else if (results == null) {
              return resolve([]);
            }
            return resolve(_.map(results, function(r) {
              return {
                topic: r._id,
                max_retries: r.max_retries
              };
            }));
          });
        };
      })(this));
    };

    RunQueueMongoDbPersistence.prototype.GetFailuresByTopic = function(ctx) {
      var pipeline;
      pipeline = [
        {
          $match: {
            di: 0,
            in_process: 1,
            fail_at: {
              $lte: new Date()
            }
          }
        }, {
          $group: {
            _id: "$topic",
            failures: {
              $sum: 1
            }
          }
        }
      ];
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this._model.aggregate(pipeline, function(err, results) {
            if (err) {
              return reject(err);
            } else if (results == null) {
              return resolve([]);
            }
            return resolve(_.map(results, function(r) {
              return {
                topic: r._id,
                failures: r.failures
              };
            }));
          });
        };
      })(this));
    };

    return RunQueueMongoDbPersistence;

  })();

  module.exports = RunQueueMongoDbPersistence;

}).call(this);
