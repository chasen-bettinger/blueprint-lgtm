// Generated by CoffeeScript 1.6.3
(function() {
  var E, INTERVAL, Push, PushSet, Q, io, sdb, _, _log,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Q = require('q');

  E = require('./error');

  _ = require('lodash');

  sdb = false;

  _log = false;

  io = false;

  INTERVAL = false;

  Push = (function() {
    function Push(kit) {
      var config;
      this.kit = kit;
      this.Poll = __bind(this.Poll, this);
      kit.services.logger.log.info('Initializing Push Service...');
      sdb = kit.services.db.mysql;
      _log = kit.services.logger.log;
      io = kit.services.io;
      config = kit.services.config.push_service;
      INTERVAL = config.poll_interval;
      this.pset_by_name = {};
      this.count = false;
      io.of('/push').on('connection', this.connect);
    }

    Push.prototype.server_init = function(kit) {
      var ctx, f,
        _this = this;
      f = 'Push:server_init';
      ctx = {
        conn: null,
        log: _log
      };
      return Q.resolve().then(function() {
        return sdb.core.Acquire();
      }).then(function(c) {
        ctx.conn = c;
        return sdb.pset_item_change.get_recent(ctx, 1, _this.count);
      }).then(function(db_rows) {
        if (db_rows.length) {
          _this.count = db_rows[db_rows.length].count;
        }
        sdb.core.release(ctx.conn);
        return _this.timer = setTimeout(_this.Poll, INTERVAL);
      });
    };

    Push.prototype.connect = function(socket) {
      var f;
      f = 'Push:connect:';
      _log.debug(f, 'client connected to push service');
      socket.emit('connected');
      socket.on('listen', function(push_handle) {
        _log.info(f, 'client wants to listen to:', push_handle);
        return socket.join(push_handle);
      });
      return socket.on('ignore', function(push_handle) {
        return _log.info(f, 'clients wants to ignore:', push_handle);
      });
    };

    Push.prototype.Poll = function() {
      var ctx, f, fromId, limit,
        _this = this;
      f = 'Push:Poll';
      ctx = {
        conn: null,
        log: _log
      };
      limit = 5;
      fromId = this.count;
      return Q.resolve().then(function() {
        return sdb.core.Acquire();
      }).then(function(c) {
        ctx.conn = c;
        return sdb.pset_item_change.get_recent(ctx, limit, fromId);
      }).then(function(db_rows) {
        if (db_rows.length) {
          _this.count = db_rows[db_rows.length - 1].count;
        }
        if (!db_rows.length) {
          return false;
        }
        return _this.ProcessChanges(db_rows);
      }).then(function() {
        sdb.core.release(ctx.conn);
        return _this.timer = setTimeout(_this.Poll, INTERVAL);
      }).fail(function(e) {
        return _log.error(f, e, e.stack);
      });
    };

    Push.prototype.ProcessChanges = function(changes) {
      var data, f;
      f = 'Push:ProcessChanges';
      data = {};
      return Q.resolve().then(function() {
        var iid, item, items, pid, pset, push_handle, push_obj, rec, _i, _len, _results;
        for (_i = 0, _len = changes.length; _i < _len; _i++) {
          rec = changes[_i];
          if (rec.verb === 'init') {
            continue;
          }
          pid = rec.pset_id;
          iid = rec.pset_item_id;
          if (!data[pid]) {
            data[pid] = {};
          }
          if (!data[pid][iid]) {
            data[pid][iid] = {};
          }
          data[pid][iid].count = rec.count;
          if (!data[pid][iid].changes) {
            data[pid][iid].changes = {};
          }
          if (!data[pid][iid].changes[rec.resource]) {
            data[pid][iid].changes[rec.resource] = [];
          }
          rec.after = JSON.parse(rec.after);
          rec.prev = JSON.parse(rec.prev);
          data[pid][iid].changes[rec.resource].push(_.pick(rec, ['id', 'count', 'verb', 'prev', 'after']));
        }
        _results = [];
        for (pset in data) {
          items = data[pset];
          _results.push((function() {
            var _results1;
            _results1 = [];
            for (item in items) {
              push_obj = items[item];
              push_handle = "" + pset + "/" + item;
              _log.debug(f, 'pushing to room:', push_handle);
              _results1.push(io.of('/push')["in"](push_handle).emit('update', push_obj));
            }
            return _results1;
          })());
        }
        return _results;
      });
    };

    Push.prototype.GetPushSet = function(ctx, clear_pset, nm) {
      var f, pset, pset_id, _ref,
        _this = this;
      f = 'Push:GetPushSet';
      _log = ctx.log;
      _log.debug(f, {
        clear_pset: clear_pset
      }, nm);
      pset_id = false;
      pset = (_ref = this.pset_by_name[nm]) != null ? _ref : false;
      if (pset && !clear_pset) {
        return pset;
      }
      return Q.resolve().then(function() {
        return sdb.core.Acquire();
      }).then(function(c) {
        if (c !== false) {
          ctx.conn = c;
        }
        return sdb.core.StartTransaction(ctx);
      }).then(function() {
        return sdb.pset.read_or_insert(ctx, nm);
      }).then(function(pset_rec) {
        _this.pset_by_name[nm] = new PushSet(pset_rec);
        pset_id = pset_rec.id;
        if (!clear_pset) {
          return false;
        }
        return _this.CleanPushSet(ctx, pset_id);
      }).then(function(clean_result) {
        _log.debug(f, 'got clean_result:', clean_result);
        return sdb.core.sqlQuery(ctx, 'COMMIT');
      }).then(function(db_result) {
        sdb.core.release(ctx.conn);
        return _this.pset_by_name[nm];
      });
    };

    Push.prototype.CleanPushSet = function(ctx, pset_id) {
      var f, item_ids;
      f = 'Push:CleanPushSet';
      _log = ctx.log;
      _log.debug(f, {
        pset_id: pset_id
      });
      item_ids = [];
      return Q.resolve().then(function() {
        return sdb.pset_item.get_by_psid(ctx, pset_id);
      }).then(function(db_rows) {
        var row, _i, _len;
        _log.debug(f, 'got item ids:', db_rows);
        for (_i = 0, _len = db_rows.length; _i < _len; _i++) {
          row = db_rows[_i];
          item_ids.push(row.id);
        }
        return sdb.pset_item_change.delete_items(ctx, item_ids);
      }).then(function(db_result) {
        _log.debug(f, 'got delete changes:', db_result);
        return sdb.pset_item.delete_pset(ctx, pset_id);
      }).then(function(db_result) {
        _log.debug(f, 'got delete items:', db_result);
        return true;
      });
    };

    return Push;

  })();

  PushSet = (function() {
    function PushSet(pset) {
      this.pset = pset;
      this.c_items = {};
    }

    PushSet.prototype.itemChange = function(ctx, xref, verb, prev, after, resource, tbl_id, tbl) {
      var f, pset_item_id,
        _this = this;
      f = "PushSet:" + this.pset.name + ":itemChange:";
      _log = ctx.log;
      _log.debug(f, {
        xref: xref,
        verb: verb,
        prev: prev,
        after: after,
        tbl_id: tbl_id,
        tbl: tbl
      });
      pset_item_id = false;
      return Q.resolve().then(function() {
        return _this.getItem(ctx, xref);
      }).then(function(item_rec) {
        _log.debug(f, {
          item_rec: item_rec
        });
        pset_item_id = item_rec.id;
        return sdb.pset_item.lock(ctx, pset_item_id);
      }).then(function(db_rows) {
        var new_change;
        if (db_rows.length !== 1) {
          throw new E.DbError('PUSHSET:ITEMCHANGE:BAD_LOCK');
        }
        prev = JSON.stringify(prev);
        after = JSON.stringify(after);
        new_change = {
          pset_id: _this.pset.id,
          pset_item_id: pset_item_id,
          verb: verb,
          prev: prev,
          after: after,
          resource: resource,
          tbl_id: tbl_id,
          tbl: tbl
        };
        return sdb.pset_item_change.create(ctx, new_change);
      }).then(function(db_result) {
        return sdb.pset_item.update_by_id(ctx, pset_item_id, {
          count: db_result.insertId
        });
      }).then(function(db_result) {
        if (db_result.affectedRows !== 1) {
          throw new E.DbError('PUSHSET:ITEMCHANGE:UPDATE_COUNT');
        }
        return null;
      });
    };

    PushSet.prototype.getItem = function(ctx, xref) {
      var f, handle, sxref, _ref,
        _this = this;
      f = "PushSet:" + this.pset.name + ":getItem:";
      _log = ctx.log;
      _log.debug(f, xref);
      sxref = String(xref);
      handle = (_ref = this.c_items[sxref]) != null ? _ref : false;
      if (handle) {
        return handle;
      }
      return Q.resolve().then(function() {
        return sdb.pset_item.get_psid_xref(ctx, _this.pset.id, sxref);
      }).then(function(db_rows) {
        _log.debug(f, 'got pset_item:', db_rows);
        if (db_rows.length) {
          _this.c_items[sxref] = db_rows[0];
          return false;
        }
        return _this._createItem(ctx, sxref);
      }).then(function(new_handle) {
        _log.debug(f, 'got new_handle:', new_handle);
        if (new_handle !== false) {
          _this.c_items[sxref] = new_handle;
        }
        return _this.c_items[sxref];
      });
    };

    PushSet.prototype.getPushHandle = function(ctx, xref) {
      var f,
        _this = this;
      f = "PushSet:" + this.pset.name + ":getPushHandle:";
      _log = ctx.log;
      return Q.resolve().then(function() {
        return _this.getItem(ctx, xref);
      }).then(function(item_rec) {
        return "" + _this.pset.id + "/" + item_rec.id;
      });
    };

    PushSet.prototype._createItem = function(ctx, xref) {
      var f, handle, pset_id,
        _this = this;
      f = "PushSet:" + this.pset.name + ":_createItem:";
      _log = ctx.log;
      _log.debug(f, xref);
      pset_id = this.pset.id;
      handle = false;
      return Q.resolve().then(function() {
        return sdb.pset_item.create(ctx, {
          pset_id: pset_id,
          xref: xref
        });
      }).then(function(db_result) {
        var id;
        _log.debug(f, 'got create pset item result:', db_result);
        id = db_result.insertId;
        return sdb.pset_item.get_by_id(ctx, id);
      }).then(function(db_rows) {
        var after, prev, resource, tbl, tbl_id;
        _log.debug(f, 'got re-read:', db_rows);
        if (db_rows.length !== 1) {
          throw new E.DbError('PUSHSET:CREATE_ITEM:REREAD');
        }
        handle = db_rows[0];
        prev = {};
        after = {};
        resource = null;
        tbl_id = null;
        tbl = null;
        return _this.itemChange(ctx, xref, 'init', prev, after, resource, tbl_id, tbl);
      }).then(function() {
        return handle;
      });
    };

    return PushSet;

  })();

  exports.Push = Push;

}).call(this);
