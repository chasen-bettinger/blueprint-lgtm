// Generated by CoffeeScript 1.4.0
var E, Push, PushSet, Q, sdb, _, _log,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Q = require('q');

E = require('./error');

_ = require('lodash');

sdb = false;

_log = false;

Push = (function() {

  function Push(kit) {
    var config;
    this.kit = kit;
    this.Poll = __bind(this.Poll, this);

    kit.services.logger.log.info('Initializing Push Service...');
    sdb = kit.services.db.mysql;
    _log = kit.services.logger.log;
    config = kit.services.config.push_service;
    this.util = kit.services.util;
    this.interval = config.poll_interval;
    this.interested_parties = [];
    this.pset_by_name = {};
    this.count = false;
  }

  Push.prototype.server_init = function(kit) {
    var ctx, f,
      _this = this;
    f = 'Push:server_init';
    ctx = {
      conn: null,
      log: _log
    };
    return Q.resolve().then(function() {
      return sdb.core.Acquire();
    }).then(function(c) {
      ctx.conn = c;
      return sdb.pset_item_change.get_recent(ctx, 1, _this.count);
    }).then(function(db_rows) {
      if (db_rows.length) {
        _this.count = db_rows[0].count;
      }
      sdb.core.release(ctx.conn);
      return _this.timer = setTimeout(_this.Poll, _this.interval);
    });
  };

  Push.prototype.RegisterForChanges = function(cb) {
    return this.interested_parties.push(cb);
  };

  Push.prototype.Poll = function() {
    var ctx, f, fromId, limit,
      _this = this;
    f = 'Push:Poll';
    ctx = {
      conn: null,
      log: _log
    };
    limit = 30;
    fromId = this.count;
    return Q.resolve().then(function() {
      return sdb.core.Acquire();
    }).then(function(c) {
      ctx.conn = c;
      return sdb.pset_item_change.get_recent(ctx, limit, fromId);
    }).then(function(db_rows) {
      if (db_rows.length) {
        _this.count = db_rows[db_rows.length - 1].count;
      }
      if (!db_rows.length) {
        return false;
      }
      return _this.ProcessChanges(db_rows);
    }).then(function() {
      sdb.core.release(ctx.conn);
      return _this.timer = setTimeout(_this.Poll, _this.interval);
    }).fail(function(e) {
      return _log.error(f, e, e.stack);
    });
  };

  Push.prototype.ProcessChanges = function(changes) {
    var data, f,
      _this = this;
    f = 'Push:ProcessChanges';
    data = {};
    return Q.resolve().then(function() {
      var cb, iid, item, items, partial_handle, pid, pset, push_obj, rec, sorted_changes, _i, _j, _len, _len1, _ref, _results;
      for (_i = 0, _len = changes.length; _i < _len; _i++) {
        rec = changes[_i];
        if (rec.verb === 'init') {
          continue;
        }
        pid = rec.pset_id;
        iid = rec.pset_item_id;
        if (!data[pid]) {
          data[pid] = {};
        }
        if (!data[pid][iid]) {
          data[pid][iid] = {};
        }
        data[pid][iid].count = rec.count;
        if (!data[pid][iid].sync) {
          data[pid][iid].sync = {};
        }
        if (!data[pid][iid].sync[rec.resource]) {
          data[pid][iid].sync[rec.resource] = [];
        }
        rec.after = JSON.parse(rec.after);
        rec.prev = JSON.parse(rec.prev);
        data[pid][iid].sync[rec.resource].push(_.pick(rec, ['id', 'count', 'verb', 'prev', 'after']));
      }
      sorted_changes = [];
      for (pset in data) {
        items = data[pset];
        for (item in items) {
          push_obj = items[item];
          partial_handle = "" + pset + "/" + item;
          push_obj.partial_handle = partial_handle;
          sorted_changes.push(push_obj);
        }
      }
      _ref = _this.interested_parties;
      _results = [];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        cb = _ref[_j];
        _results.push(cb(sorted_changes));
      }
      return _results;
    });
  };

  Push.prototype.GetPushSet = function(ctx, clear_pset, nm) {
    var f, pset, pset_id, _ref,
      _this = this;
    f = 'Push:GetPushSet:';
    _log = ctx.log;
    _log.debug(f, {
      clear_pset: clear_pset
    }, nm);
    pset_id = false;
    pset = (_ref = this.pset_by_name[nm]) != null ? _ref : false;
    if (pset && !clear_pset) {
      return pset;
    }
    return Q.resolve().then(function() {
      return sdb.core.Acquire();
    }).then(function(c) {
      if (c !== false) {
        ctx.conn = c;
      }
      return sdb.core.StartTransaction(ctx);
    }).then(function() {
      return sdb.pset.read_or_insert(ctx, nm);
    }).then(function(pset_rec) {
      _this.pset_by_name[nm] = new PushSet(pset_rec, _this.util);
      pset_id = pset_rec.id;
      if (!clear_pset) {
        return false;
      }
      return _this.CleanPushSet(ctx, pset_id);
    }).then(function(clean_result) {
      _log.debug(f, 'got clean_result:', clean_result);
      return sdb.core.sqlQuery(ctx, 'COMMIT');
    }).then(function(db_result) {
      sdb.core.release(ctx.conn);
      return _this.pset_by_name[nm];
    });
  };

  Push.prototype.CleanPushSet = function(ctx, pset_id) {
    var f, item_ids;
    f = 'Push:CleanPushSet';
    _log = ctx.log;
    _log.debug(f, {
      pset_id: pset_id
    });
    item_ids = [];
    return Q.resolve().then(function() {
      return sdb.pset_item.get_by_psid(ctx, pset_id);
    }).then(function(db_rows) {
      var row, _i, _len;
      _log.debug(f, 'got item ids:', db_rows);
      for (_i = 0, _len = db_rows.length; _i < _len; _i++) {
        row = db_rows[_i];
        item_ids.push(row.id);
      }
      return sdb.pset_item_change.delete_items(ctx, item_ids);
    }).then(function(db_result) {
      _log.debug(f, 'got delete changes:', db_result);
      return sdb.pset_item.delete_pset(ctx, pset_id);
    }).then(function(db_result) {
      _log.debug(f, 'got delete items:', db_result);
      return true;
    });
  };

  return Push;

})();

PushSet = (function() {

  function PushSet(pset, util) {
    this.pset = pset;
    this.util = util;
    this.c_items = {};
  }

  PushSet.prototype.itemChange = function(ctx, xref, verb, prev, now, resource, tbl_id, tbl) {
    var after, before, f, pset_item_id, _ref,
      _this = this;
    f = "PushSet:" + this.pset.name + ":itemChange:";
    _log = ctx.log;
    _log.debug(f, {
      xref: xref,
      verb: verb,
      resource: resource,
      tbl_id: tbl_id,
      tbl: tbl
    });
    pset_item_id = false;
    _ref = this.util.Diff(prev, now), before = _ref[0], after = _ref[1];
    _log.debug(f, {
      before: before,
      after: after
    });
    if ((_.isEmpty(after)) && verb === 'update') {
      return false;
    }
    return Q.resolve().then(function() {
      return _this.getItem(ctx, xref);
    }).then(function(item_rec) {
      _log.debug(f, {
        item_rec: item_rec
      });
      pset_item_id = item_rec.id;
      return sdb.pset_item.lock(ctx, pset_item_id);
    }).then(function(db_rows) {
      var new_change;
      if (db_rows.length !== 1) {
        throw new E.DbError('PUSHSET:ITEMCHANGE:BAD_LOCK');
      }
      before = JSON.stringify(before);
      after = JSON.stringify(after);
      new_change = {
        pset_id: _this.pset.id,
        pset_item_id: pset_item_id,
        verb: verb,
        prev: before,
        after: after,
        resource: resource,
        tbl_id: tbl_id,
        tbl: tbl
      };
      return sdb.pset_item_change.create(ctx, new_change);
    }).then(function(db_result) {
      return sdb.pset_item.update_by_id(ctx, pset_item_id, {
        count: db_result.insertId
      });
    }).then(function(db_result) {
      if (db_result.affectedRows !== 1) {
        throw new E.DbError('PUSHSET:ITEMCHANGE:UPDATE_COUNT');
      }
      return null;
    });
  };

  PushSet.prototype.getItem = function(ctx, xref) {
    var f, handle, sxref, _ref,
      _this = this;
    f = "PushSet:" + this.pset.name + ":getItem:";
    _log = ctx.log;
    _log.debug(f, xref);
    sxref = String(xref);
    handle = (_ref = this.c_items[sxref]) != null ? _ref : false;
    if (handle) {
      return handle;
    }
    return Q.resolve().then(function() {
      return sdb.pset_item.get_psid_xref(ctx, _this.pset.id, sxref);
    }).then(function(db_rows) {
      _log.debug(f, 'got pset_item:', db_rows);
      if (db_rows.length) {
        _this.c_items[sxref] = db_rows[0];
        return false;
      }
      return _this._createItem(ctx, sxref);
    }).then(function(new_handle) {
      _log.debug(f, 'got new_handle:', new_handle);
      if (new_handle !== false) {
        _this.c_items[sxref] = new_handle;
      }
      return _this.c_items[sxref];
    });
  };

  PushSet.prototype.getPushHandle = function(ctx, xref) {
    var f,
      _this = this;
    f = "PushSet:" + this.pset.name + ":getPushHandle:";
    _log = ctx.log;
    return Q.resolve().then(function() {
      return _this.getItem(ctx, xref);
    }).then(function(item_rec) {
      return "" + _this.pset.id + "/" + item_rec.id;
    });
  };

  PushSet.prototype._createItem = function(ctx, xref) {
    var f, handle, pset_id,
      _this = this;
    f = "PushSet:" + this.pset.name + ":_createItem:";
    _log = ctx.log;
    _log.debug(f, xref);
    pset_id = this.pset.id;
    handle = false;
    return Q.resolve().then(function() {
      return sdb.pset_item.create(ctx, {
        pset_id: pset_id,
        xref: xref
      });
    }).then(function(db_result) {
      var id;
      _log.debug(f, 'got create pset item result:', db_result);
      id = db_result.insertId;
      return sdb.pset_item.get_by_id(ctx, id);
    }).then(function(db_rows) {
      var after, prev, resource, tbl, tbl_id;
      _log.debug(f, 'got re-read:', db_rows);
      if (db_rows.length !== 1) {
        throw new E.DbError('PUSHSET:CREATE_ITEM:REREAD');
      }
      handle = db_rows[0];
      prev = {};
      after = {};
      resource = null;
      tbl_id = null;
      tbl = null;
      return _this.itemChange(ctx, xref, 'init', prev, after, resource, tbl_id, tbl);
    }).then(function() {
      return handle;
    });
  };

  return PushSet;

})();

exports.Push = Push;
