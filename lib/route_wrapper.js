// Generated by CoffeeScript 1.6.3
(function() {
  var E, Q, Wrapper, odb, pre_loader, sdb, _log;

  Q = require('q');

  E = require('./error');

  _log = false;

  odb = false;

  sdb = false;

  pre_loader = false;

  Wrapper = (function() {
    function Wrapper(db, pl, log) {
      _log = log;
      _log.info('Initializing Route Wrappers...');
      odb = db.mongo;
      sdb = db.mysql;
      pre_loader = pl;
    }

    Wrapper.prototype.auth_wrap = function(logic) {
      var auth_func;
      auth_func = this.auth;
      return function(q, s, n) {
        return auth_func(q, s, n, logic);
      };
    };

    Wrapper.prototype.read_wrap = function(caller, logic) {
      var read_func;
      read_func = this.read;
      return function(q, s, n) {
        return read_func(q, s, n, caller, logic);
      };
    };

    Wrapper.prototype.update_wrap = function(caller, logic) {
      var update_func;
      update_func = this.update;
      return function(q, s, n) {
        return update_func(q, s, n, caller, logic);
      };
    };

    Wrapper.prototype.auth = function(req, res, next, route_logic) {
      var conn, f, p, pre_loaded, send_result, supported_grant_type, _ref;
      f = {
        wrapper: "Auth"
      };
      conn = null;
      p = req.params;
      pre_loaded = {};
      send_result = false;
      supported_grant_type = (_ref = p.grant_type) === 'password' || _ref === 'refresh_token' ? true : false;
      return Q.resolve().then(function() {
        if (!p.client_id) {
          throw new E.OAuthError(400, 'unauthorized_client');
        }
        if (!supported_grant_type) {
          throw new E.OAuthError(400, 'unsupported_grant_type');
        }
        return sdb.core.AcquireTxConn();
      }).then(function(c) {
        conn = c;
        return route_logic(conn, p, pre_loaded, req.log);
      }).then(function(result_hash) {
        send_result = result_hash.send;
        return sdb.core.sqlQuery(conn, 'COMMIT');
      }).then(function(db_result) {
        if (conn !== null) {
          sdb.core.release(conn);
        }
        res.send(send_result);
        return next();
      }).fail(function(err) {
        var _ref1;
        if ((_ref1 = err.statusCode) !== 400 && _ref1 !== 401 && _ref1 !== 403) {
          req.log.error(f, '.fail', err, err.stack);
        } else {
          req.log.debug(f, '.fail', err);
        }
        if (err.body && err.body.error === 'invalid_client') {
          res.setHeader('WWW-Authenticate', 'Bearer realm="blueprint"');
        }
        if (conn !== null) {
          conn.query('ROLLBACK', function(err) {
            if (err) {
              req.log.warn(f, 'destroy db conn (failed rollback)');
              sdb.core.destroy(conn);
              return req.log.error(f, '.fail', err.stack);
            } else {
              req.log.debug(f, 'release db conn (successful rollback)');
              return sdb.core.release(conn);
            }
          });
        }
        res.send(err);
        return next();
      });
    };

    Wrapper.prototype.read = function(req, res, next, caller, route_logic) {
      var conn, f, p, pre_loaded;
      f = {
        wrapper: "Read:" + caller.name
      };
      conn = null;
      p = req.params;
      pre_loaded = {};
      return Q.resolve().then(function() {
        if (!caller.sql_conn) {
          return false;
        }
        return sdb.core.Acquire();
      }).then(function(c) {
        if (c !== false) {
          conn = c;
        }
        if (!caller.load_user) {
          return false;
        }
        return pre_loader.load_user(conn, p.usid);
      }).then(function(user) {
        req.log.debug('got pre_loaded user:', f, user);
        pre_loaded.user = user;
        return route_logic(conn, req.params, pre_loaded, req.log);
      }).then(function(result_hash) {
        if (conn !== null) {
          odb.mysql.core.release(conn);
        }
        res.send(result_hash.send);
        return next();
      }).fail(function(err) {
        req.log.error(f, '.fail', err, err.stack);
        res.send(err);
        return next();
      });
    };

    Wrapper.prototype.update = function(req, res, next, caller, route_logic) {
      var conn, f, pre_loaded, result;
      f = {
        wrapper: 'update',
        caller: caller.name
      };
      conn = null;
      result = false;
      pre_loaded = {};
      if (caller.auth_required) {
        if (!req.auth.authorize()) {
          return next();
        }
      }
      return Q.resolve().then(function() {
        if (!caller.sql_conn) {
          return false;
        }
        return sdb.core.AcquireTxConn();
      }).then(function(c) {
        if (c !== false) {
          conn = c;
        }
        if (!caller.load_user) {
          return false;
        }
        return pre_loader.load_user(conn, p.usid);
      }).then(function(user) {
        req.log.debug(f, 'got pre_loaded user:', user);
        pre_loaded.user = user;
        return route_logic(conn, req.params, pre_loaded, req.log);
      }).then(function(result_hash) {
        result = result_hash;
        if (!caller.sql_conn) {
          return false;
        }
        return sdb.core.sqlQuery(conn, 'COMMIT');
      }).then(function(db_result) {
        if (conn !== null) {
          sdb.core.release(conn);
        }
        res.send(result.send);
        return next();
      }).fail(function(err) {
        var _ref;
        if ((_ref = err.statusCode) !== 400 && _ref !== 403) {
          req.log.error(f, '.fail', err, err.stack);
        } else {
          req.log.debug(f, '.fail', err);
        }
        if (conn !== null) {
          conn.query('ROLLBACK', function(err) {
            if (err) {
              req.log.warn(f, 'destroy db conn (failed rollback)');
              odb.mysql.core.destroy(conn);
              return req.log.error(f, '.fail', err.stack);
            } else {
              req.log.debug(f, 'release db conn (successful rollback)');
              return odb.mysql.core.release(conn);
            }
          });
        }
        res.send(err);
        return next();
      });
    };

    return Wrapper;

  })();

  exports.Wrapper = Wrapper;

}).call(this);
