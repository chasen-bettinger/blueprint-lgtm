// Generated by CoffeeScript 1.6.3
(function() {
  var Q, Wrapper, odb, pre_loader, _log;

  Q = require('q');

  _log = false;

  odb = false;

  pre_loader = false;

  Wrapper = (function() {
    function Wrapper(db, pl, log) {
      _log = log;
      _log.info('Initializing Route Wrappers...');
      odb = db;
      pre_loader = pl;
    }

    Wrapper.prototype.read_wrap = function(caller, logic) {
      var read_func;
      read_func = this.read;
      return function(q, s, n) {
        return read_func(q, s, n, caller, logic);
      };
    };

    Wrapper.prototype.update_wrap = function(caller, logic) {
      var update_func;
      update_func = this.update;
      return function(q, s, n) {
        return update_func(q, s, n, caller, logic);
      };
    };

    Wrapper.prototype.read = function(req, res, next, caller, route_logic) {
      var conn, f, p, pre_loaded;
      f = {
        wrapper: "Read:" + caller.name
      };
      conn = null;
      p = req.params;
      pre_loaded = {};
      return Q.resolve().then(function() {
        return odb.core.Acquire();
      }).then(function(c) {
        req.log.debug(f, 'Acquired Connection');
        conn = c;
        if (!caller.load_user) {
          return false;
        }
        return pre_loader.load_user(conn, p.usid);
      }).then(function(user) {
        req.log.debug(f, 'got pre_loaded user:', user);
        pre_loaded.user = user;
        return route_logic(conn, req.params, pre_loaded, req.log);
      }).then(function(result_hash) {
        if (conn !== null) {
          odb.core.release(conn);
        }
        res.send(result_hash.send);
        return next();
      }).fail(function(err) {
        req.log.error(f, '.fail', err, err.stack);
        res.send(err);
        return next();
      });
    };

    Wrapper.prototype.update = function(req, res, next, caller, route_logic) {
      var conn, f, pre_loaded, result;
      f = {
        wrapper: "Update:" + caller.name
      };
      conn = null;
      result = false;
      pre_loaded = {};
      if (caller.auth_required) {
        req.log.debug(f, 'auth_required is not implemented');
      }
      return Q.resolve().then(function() {
        return odb.core.Acquire();
      }).then(function(c) {
        var sql;
        req.log.debug(f, 'Acquired Connection');
        conn = c;
        sql = 'SET TRANSACTION ISOLATION LEVEL SERIALIZABLE';
        return odb.core.sqlQuery(conn, sql);
      }).then(function(db_result) {
        var sql;
        sql = 'START TRANSACTION';
        return odb.core.sqlQuery(conn, sql);
      }).then(function(db_result) {
        if (!caller.load_user) {
          return false;
        }
        return pre_loader.load_user(conn, p.usid);
      }).then(function(user) {
        req.log.debug(f, 'got pre_loaded user:', user);
        pre_loaded.user = user;
        return route_logic(conn, req.params, pre_loaded, req.log);
      }).then(function(result_hash) {
        result = result_hash;
        return odb.core.sqlQuery(conn, 'COMMIT');
      }).then(function(db_result) {
        if (conn !== null) {
          odb.core.release(conn);
        }
        res.send(result.send);
        return next();
      }).fail(function(err) {
        req.log.error(f, '.fail', err, err.stack);
        if (conn !== null) {
          conn.query('ROLLBACK', function(err) {
            if (err) {
              req.log.warn(f, 'destroy db conn (error rolling back transaction)');
              odb.core.destroy(conn);
              return req.log.error(f, '.fail', err.stack);
            } else {
              req.log.info(f, 'release db conn (successful transaction rollback)');
              return odb.core.release(conn);
            }
          });
        }
        res.send(err);
        return next();
      });
    };

    Wrapper.prototype._check_auth = function() {
      return true;
    };

    return Wrapper;

  })();

  exports.Wrapper = Wrapper;

}).call(this);
