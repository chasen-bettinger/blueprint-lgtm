// Generated by CoffeeScript 1.6.3
(function() {
  var E, Q, Wrapper, odb, pre_loader, routes, sdb, _log;

  Q = require('q');

  E = require('./error');

  _log = false;

  odb = false;

  sdb = false;

  pre_loader = false;

  routes = false;

  Wrapper = (function() {
    function Wrapper(kits, kit_routes) {
      kits.logger.log.info('Initializing Route Wrappers...');
      _log = kits.logger.log;
      odb = kits.db.mongo;
      sdb = kits.db.mysql;
      routes = kit_routes;
    }

    Wrapper.prototype.add = function(mod, func) {
      var caller, wrap;
      caller = routes[mod].caller[func];
      caller.name = mod + ':' + func;
      return wrap = this[caller.wrap](caller);
    };

    Wrapper.prototype.auth_wrap = function(caller) {
      var auth_func;
      auth_func = this.auth;
      return function(q, s, n) {
        return auth_func(q, s, n, caller);
      };
    };

    Wrapper.prototype.read_wrap = function(caller) {
      var read_func;
      read_func = this.read;
      return function(q, s, n) {
        return read_func(q, s, n, caller);
      };
    };

    Wrapper.prototype.update_wrap = function(caller) {
      var update_func;
      update_func = this.update;
      return function(q, s, n) {
        return update_func(q, s, n, caller);
      };
    };

    Wrapper.prototype.auth = function(req, res, next, caller) {
      var conn, f, p, pre_loaded, route_logic, send_result, supported_grant_type, _ref, _ref1, _ref2;
      f = "Wrapper:auth";
      route_logic = (_ref = caller.version[(_ref1 = req.params) != null ? _ref1.Version : void 0]) != null ? _ref : caller.version.any;
      if (req === 'use') {
        return (caller.use !== true ? caller.use : route_logic(req));
      }
      conn = null;
      p = req.params;
      pre_loaded = {};
      send_result = false;
      supported_grant_type = (_ref2 = p.grant_type) === 'password' || _ref2 === 'refresh_token' ? true : false;
      return Q.resolve().then(function() {
        if (!p.client_id) {
          throw new E.OAuthError(400, 'unauthorized_client');
        }
        if (!supported_grant_type) {
          throw new E.OAuthError(400, 'unsupported_grant_type');
        }
        return sdb.core.AcquireTxConn();
      }).then(function(c) {
        conn = c;
        return route_logic(conn, p, pre_loaded, req.log);
      }).then(function(result_hash) {
        send_result = result_hash.send;
        return sdb.core.sqlQuery(conn, 'COMMIT');
      }).then(function(db_result) {
        if (conn !== null) {
          sdb.core.release(conn);
        }
        res.send(send_result);
        return next();
      }).fail(function(err) {
        var _ref3;
        if ((_ref3 = err.statusCode) !== 400 && _ref3 !== 401 && _ref3 !== 403) {
          req.log.error(f, '.fail', err, err.stack);
        } else {
          req.log.debug(f, '.fail', err);
        }
        if (err.body && err.body.error === 'invalid_client') {
          res.setHeader('WWW-Authenticate', 'Bearer realm="blueprint"');
        }
        if (conn !== null) {
          conn.query('ROLLBACK', function(err) {
            if (err) {
              req.log.warn(f, 'destroy db conn (failed rollback)');
              sdb.core.destroy(conn);
              return req.log.error(f, '.fail', err.stack);
            } else {
              req.log.debug(f, 'release db conn (successful rollback)');
              return sdb.core.release(conn);
            }
          });
        }
        res.send(err);
        return next();
      });
    };

    Wrapper.prototype.read = function(req, res, next, caller) {
      var conn, f, p, pre_loaded, route_logic, _ref, _ref1;
      f = "Wrapper:read:" + caller.name;
      route_logic = (_ref = caller.version[(_ref1 = req.params) != null ? _ref1.Version : void 0]) != null ? _ref : caller.version.any;
      if (req === 'use') {
        return (caller.use !== true ? caller.use : route_logic(req));
      }
      conn = null;
      p = req.params;
      pre_loaded = {};
      if (caller.auth_required) {
        if (!req.auth.authorize()) {
          return next();
        }
      }
      return Q.resolve().then(function() {
        if (!caller.sql_conn) {
          return false;
        }
        return sdb.core.Acquire();
      }).then(function(c) {
        var func, nm, q_result, _fn, _ref2;
        if (c !== false) {
          conn = c;
        }
        q_result = Q.resolve(true);
        _ref2 = caller.pre_load;
        _fn = function(nm, func) {
          return q_result = q_result.then(function() {
            return func(conn, p);
          }).then(function(pre_load_result) {
            _log.debug("got " + nm + ":", pre_load_result);
            return pre_loaded[nm] = pre_load_result;
          });
        };
        for (nm in _ref2) {
          func = _ref2[nm];
          _fn(nm, func);
        }
        return q_result;
      }).then(function() {
        return route_logic(conn, p, pre_loaded, req.log);
      }).then(function(result_hash) {
        if (conn !== null) {
          sdb.core.release(conn);
        }
        res.send(result_hash.send);
        return next();
      }).fail(function(err) {
        req.log.error(f, '.fail', err, err.stack);
        res.send(err);
        return next();
      });
    };

    Wrapper.prototype.update = function(req, res, next, caller) {
      var conn, f, p, pre_loaded, result, route_logic, _ref, _ref1;
      f = "Wrapper:update:" + caller.name;
      route_logic = (_ref = caller.version[(_ref1 = req.params) != null ? _ref1.Version : void 0]) != null ? _ref : caller.version.any;
      if (req === 'use') {
        return (caller.use !== true ? caller.use : route_logic(req));
      }
      conn = null;
      result = false;
      p = req.params;
      pre_loaded = {};
      if (caller.auth_required) {
        if (!req.auth.authorize()) {
          return next();
        }
      }
      return Q.resolve().then(function() {
        if (!caller.sql_conn) {
          return false;
        }
        return sdb.core.AcquireTxConn();
      }).then(function(c) {
        var func, nm, q_result, _fn, _ref2;
        if (c !== false) {
          conn = c;
        }
        q_result = Q.resolve(true);
        _ref2 = caller.pre_load;
        _fn = function(nm, func) {
          return q_result = q_result.then(function() {
            return func(conn, p);
          }).then(function(pre_load_result) {
            _log.debug("got " + nm + ":", pre_load_result);
            return pre_loaded[nm] = pre_load_result;
          });
        };
        for (nm in _ref2) {
          func = _ref2[nm];
          _fn(nm, func);
        }
        return q_result;
      }).then(function() {
        return route_logic(conn, p, pre_loaded, req.log);
      }).then(function(result_hash) {
        result = result_hash;
        if (!caller.sql_conn) {
          return false;
        }
        return sdb.core.sqlQuery(conn, 'COMMIT');
      }).then(function(db_result) {
        if (conn !== null) {
          sdb.core.release(conn);
        }
        res.send(result.send);
        return next();
      }).fail(function(err) {
        var _ref2;
        if ((_ref2 = err.statusCode) !== 400 && _ref2 !== 403) {
          req.log.error(f, '.fail', err, err.stack);
        } else {
          req.log.debug(f, '.fail', err);
        }
        if (conn !== null) {
          conn.query('ROLLBACK', function(err) {
            if (err) {
              req.log.warn(f, 'destroy db conn (failed rollback)');
              sdb.core.destroy(conn);
              return req.log.error(f, '.fail', err.stack);
            } else {
              req.log.debug(f, 'release db conn (successful rollback)');
              return sdb.core.release(conn);
            }
          });
        }
        res.send(err);
        return next();
      });
    };

    return Wrapper;

  })();

  exports.Wrapper = Wrapper;

}).call(this);
