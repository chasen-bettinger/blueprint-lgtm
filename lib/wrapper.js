// Generated by CoffeeScript 1.9.2
(function() {
  var E, Q, Wrapper, _log, config, odb, request_count, request_count_high, sdb,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Q = require('q');

  E = require('./error');

  _log = false;

  odb = false;

  sdb = false;

  config = false;

  request_count = 0;

  request_count_high = 0;

  Wrapper = (function() {
    function Wrapper(kit) {
      this["default"] = bind(this["default"], this);
      this.auth = bind(this.auth, this);
      this.add = bind(this.add, this);
      this.add_wrap = bind(this.add_wrap, this);
      _log = kit.services.logger.log;
      odb = kit.services.db.mongo;
      sdb = kit.services.db.mysql;
      config = kit.services.config;
      this.routes = kit.routes;
      this.router = kit.services.router;
      this.wraps = {};
    }

    Wrapper.prototype.server_init = function(kit) {
      return this.lamd = kit.services.lamd;
    };

    Wrapper.prototype.start_connection_limit = function() {
      if (config.throttling.max_connections && request_count > config.throttling.max_connections) {
        throw new E.TooManyConnectionsError("Max:" + config.throttling.max_connections + ", Count:" + request_count);
      }
      request_count++;
      if (request_count_high < request_count) {
        return request_count_high = request_count;
      }
    };

    Wrapper.prototype.end_connection_limit = function() {
      if (request_count) {
        return request_count--;
      }
    };

    Wrapper.prototype.add_wrap = function(mod, wrap) {
      return this.wraps[mod] = wrap;
    };

    Wrapper.prototype.add = function(mod) {
      var endpoint, f, func, ref, results, wrap;
      f = 'Wrapper:add:';
      if (mod in this.wraps) {
        return this.wraps[mod](mod);
      }
      ref = this.routes[mod].endpoints;
      results = [];
      for (func in ref) {
        endpoint = ref[func];
        endpoint.name = mod + ':' + func;
        wrap = this[endpoint.wrap](endpoint);
        results.push(this.router.AddRoute(mod, func, endpoint.verb, endpoint.route, wrap));
      }
      return results;
    };

    Wrapper.prototype.auth_wrap = function(caller) {
      var auth_func;
      auth_func = this.auth;
      return function(q, s, n) {
        return auth_func(q, s, n, caller);
      };
    };

    Wrapper.prototype.default_wrap = function(caller) {
      var func;
      func = this["default"];
      return function(q, s, n) {
        return func(q, s, n, caller);
      };
    };

    Wrapper.prototype.simple_wrap = function(caller) {
      var func;
      func = this.simple;
      return function(q, s, n) {
        return func(q, s, n, caller);
      };
    };

    Wrapper.prototype.simple = function(req, res, next, caller) {
      var f, ref, ref1, route_logic;
      f = "Wrapper:simple:" + caller.name;
      route_logic = (ref = caller.version[(ref1 = req.params) != null ? ref1.Version : void 0]) != null ? ref : caller.version.any;
      if (req === 'use') {
        return route_logic(req);
      }
      if (caller.auth_required) {
        if (!req.auth.authorize()) {
          return next();
        }
      }
      return route_logic(req, res, next);
    };

    Wrapper.prototype.auth = function(req, res, next, caller) {
      var ctx, f, p, pre_loaded, ref, ref1, ref2, route_logic, send_result, supported_grant_type;
      f = "Wrapper:auth";
      if (!config.db.mysql.enable) {
        throw new E.ServerError('WRAPPER:AUTH:MYSQL_NOT_ENABLED');
      }
      route_logic = (ref = caller.version[(ref1 = req.params) != null ? ref1.Version : void 0]) != null ? ref : caller.version.any;
      if (req === 'use') {
        return (caller.use !== true ? caller.use : route_logic(req));
      }
      ctx = {
        conn: null,
        p: req.params,
        log: req.log
      };
      p = ctx.p;
      pre_loaded = {};
      send_result = false;
      supported_grant_type = (ref2 = p.grant_type) === 'password' || ref2 === 'refresh_token' || ref2 === 'client_credentials' ? true : false;
      this.start_connection_limit();
      p.request_count = request_count;
      p.request_count_high = request_count_high;
      return Q.resolve().then((function(_this) {
        return function() {
          if (!p.client_id) {
            throw new E.MissingArg('client_id');
          }
          if (!supported_grant_type) {
            throw new E.OAuthError(400, 'unsupported_grant_type');
          }
          return sdb.core.Acquire();
        };
      })(this)).then((function(_this) {
        return function(c) {
          if (c !== false) {
            ctx.conn = c;
          }
          return sdb.core.StartTransaction(ctx);
        };
      })(this)).then((function(_this) {
        return function() {
          return route_logic(ctx, pre_loaded);
        };
      })(this)).then((function(_this) {
        return function(result_hash) {
          send_result = result_hash.send;
          return sdb.core.sqlQuery(ctx, 'COMMIT');
        };
      })(this)).then((function(_this) {
        return function(db_result) {
          if (ctx.conn !== null) {
            sdb.core.release(ctx.conn);
          }
          res.send(send_result);
          _this.end_connection_limit();
          return next();
        };
      })(this)).fail((function(_this) {
        return function(err) {
          var ref3;
          if ((ref3 = err.statusCode) !== 400 && ref3 !== 401 && ref3 !== 403) {
            req.log.error(f, '.fail', err, err.stack);
          } else {
            req.log.debug(f, '.fail', err, err.stack);
          }
          if (err.body && err.body.error === 'invalid_client') {
            res.setHeader('WWW-Authenticate', "Bearer realm=" + config.auth.bearer);
          }
          if (ctx.conn !== null) {
            ctx.conn.query('ROLLBACK', function(err) {
              if (err) {
                req.log.warn(f, 'destroy db conn (failed rollback)');
                sdb.core.destroy(ctx.conn);
                return req.log.error(f, '.fail', err.stack);
              } else {
                req.log.debug(f, 'release db conn (successful rollback)');
                return sdb.core.release(ctx.conn);
              }
            });
          }
          res.send(err);
          _this.end_connection_limit();
          return next();
        };
      })(this));
    };

    Wrapper.prototype["default"] = function(req, res, next, endpoint) {
      var ctx, f, p, pre_loaded, ref, ref1, ref2, ref3, result, route_logic;
      f = "Wrapper:default:" + endpoint.name;
      route_logic = (ref = endpoint.version[(ref1 = req.params) != null ? ref1.Version : void 0]) != null ? ref : endpoint.version.any;
      if (req === 'use') {
        return (endpoint.use !== true ? endpoint.use : route_logic(req));
      }
      ctx = {
        conn: null,
        p: req.params,
        log: req.log,
        auth_id: (ref2 = req.auth) != null ? ref2.authId : void 0,
        files: req.files,
        req: req,
        res: res,
        lamd: {
          start: new Date().getTime(),
          route: endpoint.route,
          verb: endpoint.verb,
          params: req.params,
          headers: req.headers,
          req_uuid: req._id,
          auth_id: 0
        }
      };
      p = ctx.p;
      pre_loaded = {};
      result = false;
      if (endpoint.auth_required || endpoint.permit) {
        if (((ref3 = config.perf) != null ? ref3.test_user_override : void 0) === true && typeof p.mock_id === "string") {
          pre_loaded.auth_id = Number(p.mock_id);
        } else {
          if (!req.auth.authorize()) {
            return next();
          }
          pre_loaded.auth_id = req.auth.authId;
        }
        ctx.lamd.auth_id = pre_loaded.auth_id;
      }
      this.start_connection_limit();
      p.request_count = ctx.lamd.request_count = request_count;
      p.request_count_high = request_count_high;
      return Q.resolve().then((function(_this) {
        return function() {
          if (!endpoint.mongo_pool) {
            return false;
          }
          if (!(endpoint.mongo_pool in odb.pool)) {
            throw new E.ServerError('WRAPPER:DEFAULT:UNKNOWN_MONGO_POOL:' + endpoint.mongo_pool);
          }
          return ctx.pool = odb.pool[endpoint.mongo_pool];
        };
      })(this)).then((function(_this) {
        return function() {
          if (!endpoint.sql_conn) {
            return false;
          }
          if (!config.db.mysql.enable) {
            throw new E.ServerError('WRAPPER:DEFAULT:MYSQL_NOT_ENABLED');
          }
          return sdb.core.Acquire();
        };
      })(this)).then((function(_this) {
        return function(c) {
          if (c !== false) {
            ctx.conn = c;
          }
          if (!endpoint.sql_tx) {
            return false;
          }
          if (!config.db.mysql.enable) {
            throw new E.ServerError('WRAPPER:DEFAULT:MYSQL_NOT_ENABLED');
          }
          return sdb.core.StartTransaction(ctx);
        };
      })(this)).then((function(_this) {
        return function() {
          var fn, func, nm, q_result, ref4;
          q_result = Q.resolve(true);
          ref4 = endpoint.pre_load;
          fn = function(nm, func) {
            return q_result = q_result.then(function() {
              return func(ctx, pre_loaded);
            }).then(function(pre_load_result) {
              _log.debug(f, "got " + nm + ":", pre_load_result);
              return pre_loaded[nm] = pre_load_result;
            });
          };
          for (nm in ref4) {
            func = ref4[nm];
            fn(nm, func);
          }
          return q_result;
        };
      })(this)).then((function(_this) {
        return function() {
          return route_logic(ctx, pre_loaded);
        };
      })(this)).then((function(_this) {
        return function(result_hash) {
          result = result_hash;
          if (!endpoint.sql_conn) {
            return false;
          }
          return sdb.core.sqlQuery(ctx, 'COMMIT');
        };
      })(this)).then((function(_this) {
        return function(db_result) {
          var end;
          delete ctx.pool;
          if (ctx.conn !== null) {
            sdb.core.release(ctx.conn);
          }
          res.send(result.send);
          ctx.lamd.statusCode = res.statusCode;
          end = new Date().getTime();
          ctx.lamd.duration = end - ctx.lamd.start;
          _this.lamd.write(ctx.lamd);
          _this.end_connection_limit();
          return next();
        };
      })(this)).fail((function(_this) {
        return function(err) {
          var end, ref4;
          delete ctx.pool;
          if ((ref4 = err.statusCode) !== 400 && ref4 !== 403) {
            req.log.error(f, '.fail', err, err.stack);
          } else {
            req.log.debug(f, '.fail', err);
          }
          if (ctx.conn !== null) {
            ctx.conn.query('ROLLBACK', function(err) {
              if (err) {
                req.log.warn(f, 'destroy db conn (failed rollback)');
                sdb.core.destroy(ctx.conn);
                return req.log.error(f, '.fail', err.stack);
              } else {
                req.log.debug(f, 'release db conn (successful rollback)');
                return sdb.core.release(ctx.conn);
              }
            });
          }
          res.send(err);
          ctx.lamd.statusCode = res.statusCode;
          end = new Date().getTime();
          ctx.lamd.duration = end - ctx.lamd.start;
          ctx.lamd.err = err;
          _this.lamd.write(ctx.lamd);
          _this.end_connection_limit();
          return next();
        };
      })(this));
    };

    return Wrapper;

  })();

  exports.Wrapper = Wrapper;

}).call(this);
