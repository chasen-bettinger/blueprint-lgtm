// Generated by CoffeeScript 1.4.0
(function() {
  var AuthRoute, E, Q, crypto, moment, sdb,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Q = require('q');

  E = require('../lib/error');

  crypto = require('crypto');

  moment = require('moment');

  sdb = false;

  AuthRoute = (function() {

    function AuthRoute(kit) {
      this._get_auth_trip = __bind(this._get_auth_trip, this);

      this._verify_forgot = __bind(this._verify_forgot, this);

      this._forgot_password = __bind(this._forgot_password, this);

      this._update_password = __bind(this._update_password, this);

      this._verify_email = __bind(this._verify_email, this);

      this._update_email = __bind(this._update_email, this);

      this._authenticate = __bind(this._authenticate, this);
      this.log = kit.services.logger.log;
      sdb = kit.services.db.mysql;
      this.ses = kit.services.ses;
      this.auth = kit.services.auth;
      this.config = kit.services.config.auth;
      this.tripMgr = kit.services.tripMgr;
      this.tokenMgr = kit.services.tokenMgr;
      this.endpoints = {
        authenticate: {
          verb: 'post',
          route: '/Auth',
          use: true,
          wrap: 'auth_wrap',
          version: {
            any: this._authenticate
          }
        },
        update_password: {
          verb: 'put',
          route: '/Auth/:auid/updatepassword',
          use: true,
          wrap: 'default_wrap',
          version: {
            any: this._update_password
          },
          sql_conn: true,
          sql_tx: true,
          auth_required: true
        },
        update_email: {
          verb: 'post',
          route: '/Auth/:auid/updateemail',
          use: true,
          wrap: 'default_wrap',
          version: {
            any: this._update_email
          },
          sql_conn: true,
          sql_tx: true,
          auth_required: true
        },
        forgot_password: {
          verb: 'post',
          route: '/AuthChange',
          use: true,
          wrap: 'default_wrap',
          version: {
            any: this._forgot_password
          },
          sql_conn: true,
          sql_tx: true
        },
        read_auth_trip: {
          verb: 'get',
          route: '/AuthChange/:token',
          use: true,
          wrap: 'default_wrap',
          version: {
            any: this._get_auth_trip
          },
          sql_conn: true
        },
        verify_forgot: {
          verb: 'post',
          route: '/AuthChange/:token/verifyforgot',
          use: true,
          wrap: 'default_wrap',
          version: {
            any: this._verify_forgot
          },
          sql_conn: true,
          sql_tx: true
        },
        verify_email: {
          verb: 'post',
          route: '/AuthChange/:token/verifyemail',
          use: true,
          wrap: 'default_wrap',
          version: {
            any: this._verify_email
          },
          sql_conn: true,
          sql_tx: true
        }
      };
    }

    AuthRoute.prototype.make_tbl = function(recipient, token) {
      return {
        Trip: [
          {
            token: token
          }
        ],
        Recipient: [
          {
            email: recipient.eml
          }
        ]
      };
    };

    AuthRoute.prototype._authenticate = function(ctx, pre_loaded) {
      var current_token, f, new_token, p, result, use_doc, _log,
        _this = this;
      use_doc = {
        params: {
          client_id: 'r:S',
          username: 'r:S',
          password: 'r:S',
          grant_type: 'r:S'
        },
        response: {
          access_token: 'string',
          token_type: 'string',
          expires_in: 'number - seconds',
          refresh_token: 'string'
        }
      };
      if (ctx === 'use') {
        return use_doc;
      }
      f = 'Auth:_authenticate:';
      p = ctx.p;
      _log = ctx.log;
      _log.debug(f, p, pre_loaded);
      current_token = false;
      new_token = false;
      result = {};
      return Q.resolve().then(function() {
        if (p.grant_type !== 'password') {
          return false;
        }
        return _this.auth.ValidateCredentials(ctx, p.username, p.password);
      }).then(function(auth_ident_id) {
        _log.debug(f, 'got auth_ident_id:', auth_ident_id);
        if (auth_ident_id !== false) {
          result.auth_ident_id = auth_ident_id;
        }
        if (p.grant_type !== 'refresh_token') {
          return false;
        }
        return sdb.token.GetNonExpiredToken(ctx, p.refresh_token);
      }).then(function(valid_token) {
        _log.debug(f, 'got valid token:', valid_token);
        if (valid_token !== false) {
          if (valid_token.length === 0) {
            throw new E.OAuthError(401, 'invalid_client');
          }
          result.auth_ident_id = valid_token[0].ident_id;
        }
        return _this.tokenMgr.CreateToken(16);
      }).then(function(token) {
        var exp, nv;
        if (p.grant_type === 'refresh_token') {
          current_token = p.refresh_token;
        }
        exp = (moment().add(_this.config.refreshTokenExpiration, 'seconds')).toDate();
        nv = {
          ident_id: result.auth_ident_id,
          client: p.client_id,
          token: token,
          exp: exp
        };
        return sdb.token.UpdateActiveToken(ctx, nv, current_token);
      }).then(function(ident_token) {
        var accessToken, exp;
        exp = moment().add(_this.config.accessTokenExpiration, 'seconds');
        accessToken = _this.tokenMgr.encode({
          iid: result.auth_ident_id
        }, exp, _this.config.key);
        return {
          send: {
            access_token: accessToken,
            token_type: 'bearer',
            expires_in: _this.config.accessTokenExpiration,
            refresh_token: ident_token.token
          }
        };
      });
    };

    AuthRoute.prototype._update_email = function(ctx, pre_loaded) {
      var conn, f, p, use_doc, _log,
        _this = this;
      use_doc = {
        params: {
          new_eml: 'r:S'
        },
        response: {
          success: 'bool'
        }
      };
      if (ctx === 'use') {
        return use_doc;
      }
      p = ctx.p;
      conn = ctx.conn;
      _log = ctx.log;
      if ((Number(p.auid)) !== pre_loaded.auth_id) {
        throw new E.AccessDenied('AUTH:UPDATE_EMAIL:AUTH_ID');
      }
      if (!p.new_eml) {
        throw new E.MissingArg('new_eml');
      }
      f = 'User:_update_email:';
      return Q.resolve().then(function() {
        return sdb.auth.GetByCredName(ctx, p.new_eml);
      }).then(function(db_rows) {
        _log.debug('got ident with new_eml:', db_rows);
        if (db_rows.length !== 0) {
          throw new E.AccessDenied('AUTH:UPDATE_EMAIL:EMAIL_EXISTS');
        }
        return _this.tripMgr.planTrip(ctx, pre_loaded.auth_id, {
          eml: p.new_eml
        }, null, 'update_email');
      }).then(function(new_trip) {
        var recipient, trip;
        _log.debug(f, 'got round trip:', new_trip);
        trip = new_trip;
        recipient = {
          eml: p.new_eml
        };
        return _this.ses.send('verify_email_change', _this.make_tbl(recipient, trip.token));
      }).then(function() {
        var success;
        success = true;
        return {
          send: {
            success: success
          }
        };
      });
    };

    AuthRoute.prototype._verify_email = function(ctx, pre_loaded) {
      var f, ident, new_eml, p, trip, use_doc, _log,
        _this = this;
      use_doc = {
        params: {},
        response: {
          success: 'bool'
        }
      };
      if (ctx === 'use') {
        return use_doc;
      }
      p = ctx.p;
      _log = ctx.log;
      trip = false;
      ident = false;
      new_eml = false;
      f = 'Auth:_verify_email:';
      return Q.resolve().then(function() {
        return _this.tripMgr.getTripFromToken(ctx, p.token);
      }).then(function(trip_info) {
        var bad_token;
        _log.debug(f, 'got round trip:', trip_info);
        trip = trip_info;
        bad_token = trip_info.status === 'unknown' || trip_info.status !== 'valid';
        if (bad_token) {
          throw new E.AccessDenied('AUTH:VERIFY_EMAIL:INVALID_TOKEN');
        }
        if (trip.domain !== 'update_email') {
          throw new E.AccessDenied('AUTH:VERIFY_EMAIL:INVALID_DOMAIN');
        }
        new_eml = (JSON.parse(trip.json)).eml;
        return sdb.auth.GetById(ctx, trip.auth_ident_id);
      }).then(function(db_rows) {
        _log.debug('got ident:', db_rows);
        if (db_rows.length !== 1) {
          throw new E.NotFoundError('AUTH:VERIFY_EMAIL:IDENT');
        }
        ident = db_rows[0];
        return sdb.auth.GetByCredName(ctx, new_eml);
      }).then(function(db_rows) {
        _log.debug('got ident with new_eml:', db_rows);
        if (db_rows.length !== 0) {
          throw new E.AccessDenied('AUTH:VERIFY_EMAIL:EMAIL_EXISTS');
        }
        return sdb.auth.update_by_id(ctx, ident.id, {
          eml: new_eml
        });
      }).then(function(db_result) {
        _log.debug(f, 'got password update result:', db_result);
        if (db_result.affectedRows !== 1) {
          throw new E.DbError('AUTH:VERIFY_EMAIL:AFFECTEDROWS');
        }
        return _this.tripMgr.returnFromTrip(ctx, trip.id);
      }).then(function() {
        var recipient;
        recipient = {
          eml: new_eml
        };
        return _this.ses.send('email_change_confirmed', _this.make_tbl(recipient));
      }).then(function() {
        var success;
        success = true;
        return {
          send: {
            success: success
          }
        };
      });
    };

    AuthRoute.prototype._update_password = function(ctx, pre_loaded) {
      var conn, f, p, use_doc, _log,
        _this = this;
      use_doc = {
        params: {
          new_pwd: 'r:S'
        },
        response: {
          success: 'bool'
        }
      };
      if (ctx === 'use') {
        return use_doc;
      }
      p = ctx.p;
      conn = ctx.conn;
      _log = ctx.log;
      if ((Number(p.auid)) !== pre_loaded.auth_id) {
        throw new E.AccessDenied('AUTH:UPDATE_PASSWORD:AUTH_ID');
      }
      if (!p.new_pwd) {
        throw new E.MissingArg('new_pwd');
      }
      f = 'User:_update_password:';
      return Q.resolve().then(function() {
        return _this.auth.EncryptPassword(p.new_pwd);
      }).then(function(pwd_hash) {
        return sdb.auth.update_by_id(ctx, pre_loaded.auth_id, {
          pwd: pwd_hash
        });
      }).then(function(db_result) {
        var success;
        _log.debug(f, 'got password update result:', db_result);
        if (db_result.affectedRows !== 1) {
          throw new E.DbError('AUTH:UPDATE_PASSWORD:AFFECTEDROWS');
        }
        success = true;
        return {
          send: {
            success: success
          }
        };
      });
    };

    AuthRoute.prototype._forgot_password = function(ctx, pre_loaded) {
      var f, ident, p, use_doc, _log,
        _this = this;
      use_doc = {
        params: {
          email: 'r:S'
        },
        response: {
          success: 'bool'
        }
      };
      if (ctx === 'use') {
        return use_doc;
      }
      p = ctx.p;
      _log = ctx.log;
      ident = false;
      if (!p.email) {
        throw new E.MissingArg('email');
      }
      f = 'Auth:_forgot_password:';
      return Q.resolve().then(function() {
        return sdb.auth.GetByCredName(ctx, p.email);
      }).then(function(db_rows) {
        _log.debug('got ident:', db_rows);
        if (db_rows.length !== 1) {
          throw new E.NotFoundError('AUTH:FORGOT_PASSWORD:IDENT');
        }
        ident = db_rows[0];
        return _this.tripMgr.planTrip(ctx, ident.id, {}, null, 'forgot_password');
      }).then(function(new_trip) {
        var trip;
        _log.debug(f, 'got round trip:', new_trip);
        if (new_trip !== false) {
          trip = new_trip;
        }
        return _this.ses.send('forgot_password', _this.make_tbl(ident, trip.token));
      }).then(function() {
        var success;
        success = true;
        return {
          send: {
            success: success
          }
        };
      });
    };

    AuthRoute.prototype._verify_forgot = function(ctx, pre_loaded) {
      var f, p, success, trip, use_doc, _log,
        _this = this;
      use_doc = {
        params: {
          new_pwd: 'r:S'
        },
        response: {
          success: 'bool'
        }
      };
      if (ctx === 'use') {
        return use_doc;
      }
      p = ctx.p;
      _log = ctx.log;
      trip = false;
      success = false;
      f = 'Auth:_verify_forgot:';
      if (!p.new_pwd) {
        throw new E.MissingArg('new_pwd');
      }
      return Q.resolve().then(function() {
        return _this.tripMgr.getTripFromToken(ctx, p.token);
      }).then(function(trip_info) {
        var bad_token;
        _log.debug(f, 'got round trip:', trip_info);
        trip = trip_info;
        bad_token = trip_info.status === 'unknown' || trip_info.status !== 'valid';
        if (bad_token) {
          throw new E.AccessDenied('AUTH:AUTH_TRIP:INVALID_TOKEN');
        }
        if (trip.domain !== 'forgot_password') {
          throw new E.AccessDenied('AUTH:AUTH_TRIP:INVALID_DOMAIN');
        }
        return _this.auth.EncryptPassword(p.new_pwd);
      }).then(function(pwd_hash) {
        return sdb.auth.update_by_id(ctx, trip.auth_ident_id, {
          pwd: pwd_hash
        });
      }).then(function(db_result) {
        _log.debug(f, 'got password update result:', db_result);
        if (db_result.affectedRows !== 1) {
          throw new E.DbError('AUTH:UPDATE_PASSWORD:AFFECTEDROWS');
        }
        return _this.tripMgr.returnFromTrip(ctx, trip.id);
      }).then(function() {
        success = true;
        return {
          send: {
            success: success
          }
        };
      });
    };

    AuthRoute.prototype._get_auth_trip = function(ctx, pre_loaded) {
      var bad_token, f, ident, p, trip, use_doc, _log,
        _this = this;
      use_doc = {
        params: {},
        response: {
          ident: 'object'
        }
      };
      if (ctx === 'use') {
        return use_doc;
      }
      p = ctx.p;
      _log = ctx.log;
      bad_token = false;
      trip = false;
      ident = false;
      f = 'Auth:_auth_trip:';
      return Q.resolve().then(function() {
        return _this.tripMgr.getTripFromToken(ctx, p.token);
      }).then(function(trip_info) {
        _log.debug(f, 'got round trip:', trip_info);
        trip = trip_info;
        bad_token = trip_info.status === 'unknown' || trip_info.status !== 'valid';
        if (bad_token) {
          throw new E.AccessDenied('AUTH:AUTH_TRIP:BAD_TOKEN');
        }
        return sdb.auth.GetById(ctx, trip.auth_ident_id);
      }).then(function(db_rows) {
        _log.debug('got ident:', db_rows);
        if (db_rows.length !== 1) {
          throw new E.NotFoundError('AUTH:AUTH_TRIP:IDENT');
        }
        ident = db_rows[0];
        ident.token = trip.token;
        return {
          send: {
            ident: ident
          }
        };
      });
    };

    AuthRoute.prototype._pl_ident = function(ctx) {
      var f,
        _this = this;
      f = 'Auth:_pl_ident:';
      ctx.log.debug(f, ctx.p);
      return Q.resolve().then(function() {
        return sdb.auth.GetById(ctx, ctx.auth_id);
      }).then(function(db_rows) {
        var ident;
        ctx.log.debug('got ident:', db_rows);
        if (db_rows.length !== 1) {
          throw new E.NotFoundError('AUTH:PRELOAD:IDENT');
        }
        return ident = db_rows[0];
      });
    };

    return AuthRoute;

  })();

  exports.AuthRoute = AuthRoute;

}).call(this);
