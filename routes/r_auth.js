// Generated by CoffeeScript 1.6.3
(function() {
  var AuthRoute, E, ITERATIONS, KEY_LENGTH, Q, SALT_SIZE, crypto, sdb,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Q = require('q');

  E = require('../lib/error');

  crypto = require('crypto');

  ITERATIONS = 150000;

  SALT_SIZE = 16;

  KEY_LENGTH = 32;

  sdb = false;

  AuthRoute = (function() {
    function AuthRoute(config, tokenMgr, db, wrapper, log) {
      this.config = config;
      this.tokenMgr = tokenMgr;
      this.log = log;
      this._authenticate = __bind(this._authenticate, this);
      this.log.info('Initializing Auth Route...');
      sdb = db.mysql;
      this.authenticate = wrapper.auth_wrap(this._authenticate);
    }

    AuthRoute.prototype._authenticate = function(conn, p, pre_loaded, _log) {
      var clearToken, f, result,
        _this = this;
      f = {
        route: 'Auth',
        fn: 'authenticate'
      };
      _log.debug(f, p, pre_loaded);
      clearToken = false;
      result = {};
      return Q.resolve().then(function() {
        if (p.grant_type !== 'password') {
          return false;
        }
        return _this._validateCredentials(conn, p.username, p.password, _log);
      }).then(function(auth_user_id) {
        _log.debug(f, 'got auth_user_id:', auth_user_id);
        if (auth_user_id !== false) {
          result.auth_user_id = auth_user_id;
        }
        if (p.grant_type !== 'refresh_token') {
          return false;
        }
        return sdb.token.find_token(conn, p.refresh_token);
      }).then(function(valid_token) {
        var exp;
        _log.debug(f, 'got valid token:', valid_token);
        if (valid_token !== false) {
          if (valid_token.length === 0) {
            throw new E.OAuthError(401, 'invalid_client');
          }
          result.auth_user_id = valid_token[0].user_id;
        }
        if (p.grant_type === 'refresh_token') {
          clearToken = p.refresh_token;
        }
        _log.debug('got clearToken:', clearToken);
        exp = (moment().add('seconds', _this.config.refreshTokenExpiration)).toDate();
        return sdb.token.createRefreshToken(conn, result.auth_user_id, p.client_id, exp, clearToken);
      }).then(function(refreshToken) {
        var accessToken, exp;
        exp = moment().add('seconds', _this.config.accessTokenExpiration);
        accessToken = _this.tokenMgr.encode({
          uid: result.auth_user_id
        }, exp, _this.config.key);
        return {
          send: {
            access_token: accessToken,
            token_type: 'bearer',
            expires_in: _this.config.accessTokenExpiration,
            refresh_token: refreshToken
          }
        };
      });
    };

    AuthRoute.prototype._validateCredentials = function(conn, username, password, _log) {
      var creds, f,
        _this = this;
      f = {
        route: 'Auth',
        fn: '_validateCredentials'
      };
      if (!_log) {
        _log = this.log;
      }
      creds = false;
      return Q.resolve().then(function() {
        return sdb.user.get_auth_credentials(conn, username);
      }).then(function(credentials) {
        _log.debug('got credentials:', credentials);
        creds = credentials;
        return _this._comparePassword(password, creds.password);
      }).then(function(a_match) {
        _log.debug('got a match:', a_match);
        if (!a_match) {
          throw new E.OAuthError(401, 'invalid_client');
        }
        return creds.id;
      });
    };

    AuthRoute.prototype._pbkdf2 = function(p, buf, IT, KL) {
      return Q.ninvoke(crypto, 'pbkdf2', p, buf, IT, KL);
    };

    AuthRoute.prototype._comparePassword = function(password, compareHash) {
      var f, parts,
        _this = this;
      f = {
        route: 'Auth',
        fn: '_comparePassword'
      };
      parts = compareHash.split('.', 2);
      if (parts.length !== 2) {
        throw new E.ServerError('auth_error', 'Missing salt on password hash');
      }
      return (this._pbkdf2(password, new Buffer(parts[0], 'base64'), ITERATIONS, KEY_LENGTH)).then(function(key) {
        if ((new Buffer(key).toString('base64')) === parts[1]) {
          return true;
        } else {
          return false;
        }
      });
    };

    AuthRoute.prototype._encryptPassword = function(password) {
      var saltBuf,
        _this = this;
      saltBuf = false;
      return Q.resolve().then(function() {
        return Q.ninvoke(crypto, 'randomBytes', SALT_SIZE);
      }).then(function(buffer) {
        saltBuf = buffer;
        return _this._pbkdf2(password, saltBuf, ITERATIONS, KEY_LENGTH);
      }).then(function(key) {
        return (saltBuf.toString('base64')) + '.' + new Buffer(key).toString('base64');
      });
    };

    return AuthRoute;

  })();

  exports.AuthRoute = AuthRoute;

}).call(this);
