// Generated by CoffeeScript 1.6.3
(function() {
  var AuthRoute, E, ITERATIONS, KEY_LENGTH, Q, SALT_SIZE, crypto, sdb,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Q = require('q');

  E = require('../lib/error');

  crypto = require('crypto');

  ITERATIONS = 150000;

  SALT_SIZE = 16;

  KEY_LENGTH = 32;

  sdb = false;

  AuthRoute = (function() {
    function AuthRoute(kit) {
      this._authenticate = __bind(this._authenticate, this);
      this._update_password = __bind(this._update_password, this);
      kit.services.logger.log.info('Initializing Auth Routes...');
      this.config = kit.services.config.auth;
      this.tokenMgr = kit.services.tokenMgr;
      sdb = kit.services.db.mysql;
      this.log = kit.services.logger.log;
      this.endpoints = {
        authenticate: {
          verb: 'post',
          route: '/Auth',
          use: true,
          wrap: 'auth_wrap',
          version: {
            any: this._authenticate
          }
        },
        update_password: {
          verb: 'put',
          route: '/Auth/:auid/updatepassword',
          use: true,
          wrap: 'update_wrap',
          version: {
            any: this._update_password
          },
          sql_conn: true,
          auth_required: true
        }
      };
    }

    AuthRoute.prototype._update_password = function(conn, p, pre_loaded, _log) {
      var f, use_doc,
        _this = this;
      use_doc = {
        new_pwd: 'S'
      };
      if (conn === 'use') {
        return use_doc;
      }
      if ((Number(p.auid)) !== pre_loaded.auth_id) {
        throw new E.AccessDenied('AUTH:UPDATE_PASSWORD:AUTH_ID');
      }
      if (!p.new_pwd) {
        throw new E.MissingArg('new_pwd');
      }
      f = 'User:_update_password:';
      return Q.resolve().then(function() {
        return _this._encryptPassword(p.new_pwd);
      }).then(function(pwd_hash) {
        return sdb.auth.update_by_id(conn, pre_loaded.auth_id, {
          pwd: pwd_hash
        });
      }).then(function(db_result) {
        _log.debug(f, 'got password update result:', db_result);
        if (db_result.affectedRows !== 1) {
          throw new E.DbError('AUTH:UPDATE_PASSWORD:AFFECTEDROWS');
        }
        return {
          send: {
            success: true
          }
        };
      });
    };

    AuthRoute.prototype._authenticate = function(conn, p, pre_loaded, _log) {
      var clearToken, f, result, use_doc,
        _this = this;
      use_doc = {
        client_id: 'rS',
        username: 'rS',
        password: 'rS',
        grant_type: 'S'
      };
      if (conn === 'use') {
        return use_doc;
      }
      f = 'Auth:_authenticate:';
      _log.debug(f, p, pre_loaded);
      clearToken = false;
      result = {};
      return Q.resolve().then(function() {
        if (p.grant_type !== 'password') {
          return false;
        }
        return _this._validateCredentials(conn, p.username, p.password, _log);
      }).then(function(auth_ident_id) {
        _log.debug(f, 'got auth_ident_id:', auth_ident_id);
        if (auth_ident_id !== false) {
          result.auth_ident_id = auth_ident_id;
        }
        if (p.grant_type !== 'refresh_token') {
          return false;
        }
        return sdb.token.find_token(conn, p.refresh_token);
      }).then(function(valid_token) {
        var exp;
        _log.debug(f, 'got valid token:', valid_token);
        if (valid_token !== false) {
          if (valid_token.length === 0) {
            throw new E.OAuthError(401, 'invalid_client');
          }
          result.auth_ident_id = valid_token[0].ident_id;
        }
        if (p.grant_type === 'refresh_token') {
          clearToken = p.refresh_token;
        }
        _log.debug('got clearToken:', clearToken);
        exp = (moment().add('seconds', _this.config.refreshTokenExpiration)).toDate();
        return sdb.token.create_ident_token(conn, result.auth_ident_id, p.client_id, exp, clearToken);
      }).then(function(refreshToken) {
        var accessToken, exp;
        exp = moment().add('seconds', _this.config.accessTokenExpiration);
        accessToken = _this.tokenMgr.encode({
          iid: result.auth_ident_id
        }, exp, _this.config.key);
        return {
          send: {
            access_token: accessToken,
            token_type: 'bearer',
            expires_in: _this.config.accessTokenExpiration,
            refresh_token: refreshToken
          }
        };
      });
    };

    AuthRoute.prototype._validateCredentials = function(conn, username, password, _log) {
      var creds, f,
        _this = this;
      f = 'Auth:_validateCredentials:';
      if (!_log) {
        _log = this.log;
      }
      creds = false;
      return Q.resolve().then(function() {
        return sdb.auth.get_auth_credentials(conn, username);
      }).then(function(credentials) {
        _log.debug('got credentials:', credentials);
        creds = credentials;
        return _this._comparePassword(password, creds.pwd);
      }).then(function(a_match) {
        _log.debug('got a match:', a_match);
        if (!a_match) {
          throw new E.OAuthError(401, 'invalid_client');
        }
        return creds.id;
      });
    };

    AuthRoute.prototype._pbkdf2 = function(p, buf, IT, KL) {
      return Q.ninvoke(crypto, 'pbkdf2', p, buf, IT, KL);
    };

    AuthRoute.prototype._comparePassword = function(password, compareHash) {
      var f, parts,
        _this = this;
      f = 'Auth:_comparePassword:';
      parts = compareHash.split('.', 2);
      if (parts.length !== 2) {
        throw new E.ServerError('auth_error', 'Missing salt on password hash');
      }
      return (this._pbkdf2(password, new Buffer(parts[0], 'base64'), ITERATIONS, KEY_LENGTH)).then(function(key) {
        if ((new Buffer(key).toString('base64')) === parts[1]) {
          return true;
        } else {
          return false;
        }
      });
    };

    AuthRoute.prototype._encryptPassword = function(password) {
      var saltBuf,
        _this = this;
      saltBuf = false;
      return Q.resolve().then(function() {
        return Q.ninvoke(crypto, 'randomBytes', SALT_SIZE);
      }).then(function(buffer) {
        saltBuf = buffer;
        return _this._pbkdf2(password, saltBuf, ITERATIONS, KEY_LENGTH);
      }).then(function(key) {
        return (saltBuf.toString('base64')) + '.' + new Buffer(key).toString('base64');
      });
    };

    return AuthRoute;

  })();

  exports.AuthRoute = AuthRoute;

}).call(this);
